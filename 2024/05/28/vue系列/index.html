<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="worked warriors" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="worked warriors" type="application/atom+xml"><link rel="alternate" type="application/json" title="worked warriors" href="http://example.com/feed.json"/><link rel="preconnect" href="https://lf9-cdn-tos.bytecdntp.com"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.2"><link rel="modulepreload" href="/js/chunk-PBF2T7BW.js"></link><link rel="modulepreload" href="/js/chunk-QAWHJ5B3.js"></link><link rel="modulepreload" href="/js/chunk-ZRX4527L.js"></link><link rel="modulepreload" href="/js/index.esm-XWNHOQIZ.js"></link><link rel="modulepreload" href="/js/post-U3LNELWM.js"></link><link rel="modulepreload" href="/js/quicklink-SX3NI42S.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="preload" href="https://img2.imgtp.com/2024/05/28/nMaw2u9w.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://img2.imgtp.com/2024/05/28/dorlGWL9.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://img2.imgtp.com/2024/05/28/Oi7AxCt9.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://img2.imgtp.com/2024/05/28/8ip84iJJ.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://img2.imgtp.com/2024/05/28/aur7gBvM.jpg" as="image" fetchpriority="high"><link rel="preload" href="https://img2.imgtp.com/2024/05/28/1ua9FT1C.jpg" as="image" fetchpriority="high"><link rel="canonical" href="http://example.com/2024/05/28/vue%E7%B3%BB%E5%88%97/"><title>vue系列</title><meta name="generator" content="Hexo 7.0.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">vue系列</h1><div class="meta"><span class="item" title="创建时间：2024-05-28 09:12:48"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">发表于</span><time itemprop="dateCreated datePublished" datetime="2024-05-28T09:12:48+08:00">2024-05-28</time></span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">本文字数</span><span>12k</span><span class="text">字</span></span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i></span><span class="text">阅读时长</span><span>11 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">TechVoy's blog</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><ul><li class="item" style="background-image: url(&quot;https://img2.imgtp.com/2024/05/28/nMaw2u9w.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://img2.imgtp.com/2024/05/28/dorlGWL9.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://img2.imgtp.com/2024/05/28/Oi7AxCt9.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://img2.imgtp.com/2024/05/28/8ip84iJJ.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://img2.imgtp.com/2024/05/28/aur7gBvM.jpg&quot;);"></li><li class="item" style="background-image: url(&quot;https://img2.imgtp.com/2024/05/28/1ua9FT1C.jpg&quot;);"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">首页</a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/study/" itemprop="item" rel="index" title="分类于平时学习"><span itemprop="name">平时学习<meta itemprop="position" content="0"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/05/28/vue%E7%B3%BB%E5%88%97/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="TechVoy"/><meta itemprop="description" content="努力过的人皆为战士, "/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="worked warriors"/></span><div class="body md" itemprop="articleBody"><h1 id="vue相关面试问题"><a class="anchor" href="#vue相关面试问题">#</a> vue 相关面试问题</h1>
<h2 id="vue的生命周期"><a class="anchor" href="#vue的生命周期">#</a> vue 的生命周期</h2>
<p>​	Vue 生命周期总共可以分为 8 个阶段</p>
<table>
<thead>
<tr>
<th>beforeCreate</th>
<th>组件实例被创建之初</th>
</tr>
</thead>
<tbody>
<tr>
<td>created</td>
<td>组件实例已经完全创建</td>
</tr>
<tr>
<td>beforeMount</td>
<td>组件挂载之前</td>
</tr>
<tr>
<td>mounted</td>
<td>组件挂载到实例上去之后</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>组件数据发生变化，更新之前</td>
</tr>
<tr>
<td>updated</td>
<td>组件数据更新之后</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>组件实例销毁之前</td>
</tr>
<tr>
<td>destroyed</td>
<td>组件实例销毁之后</td>
</tr>
<tr>
<td>activated</td>
<td>keep-alive 缓存的组件激活时</td>
</tr>
<tr>
<td>deactivated</td>
<td>keep-alive 缓存的组件停用时调用</td>
</tr>
<tr>
<td>errorCaptured</td>
<td>捕获一个来自子孙组件的错误时被调用</td>
</tr>
</tbody>
</table>
<p>在 vue2 和 vue3 中的生命周期钩子函数有所不同：</p>
<p>​	vue3 中多了 setup 生命周期，所以 vue3 中的 created 和 beforecreate 换成了 setup，销毁换成了 onBeforeUnmount 和 onUnmounted。此外被包含在 &lt;keep-alive&gt; 中的组件，会多出两个生命周期钩子函数，被激活时执行 onActivated ，停用时执行 deactivated。</p>
<h2 id="vue的响应式原理"><a class="anchor" href="#vue的响应式原理">#</a> vue 的响应式原理</h2>
<p>​	在 vue2，和 vue3 中响应式原理时不同的。在 vue2 中使用的是 object.defineProperty 进行数据劫持的。</p>
<h3 id="方法1objectdefineproperty实现"><a class="anchor" href="#方法1objectdefineproperty实现">#</a> 方法 1.Object.defineProperty 实现</h3>
<p>给数据赋予 <code>getter</code>  和 <code>setter</code> 。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> middle = <span class="number">6</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data,<span class="string">&#x27;age&#x27;</span>,&#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;获取age&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> middle</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">parmas</span>)&#123;</span><br><span class="line">    <span class="comment">//参数就是赋值的数据</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;修改age数据&#x27;</span>,parmas)</span><br><span class="line">    middle = parmas</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line"><span class="comment">// 取值的时候触发getter</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">age</span>)</span><br><span class="line"><span class="comment">//赋值的时候触发setter</span></span><br><span class="line">data.<span class="property">age</span> = <span class="number">15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">age</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>而每个 setter 方法就是一个观察者，在数据变更的时候通知订阅者更新视图。当数据发生变化时页面上的数据会实时改变，更新页面。但这种方法<strong>无法检测到对象属性的添加或删除</strong> (如 <code>data.location.a=1</code> )； <code>getter/setter</code>  只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。所以 ** <code>Object.defineProperty</code>  不能监听数组的变化，需要进行数组方法的重写 **</p>
<h3 id="方法2proxy实现"><a class="anchor" href="#方法2proxy实现">#</a> 方法 2.Proxy 实现</h3>
<p>​	 <code>Proxy</code>  是 JavaScript 2015 的一个新特性。<strong> <code>Proxy</code>  的代理是针对整个对象的，而不是对象的某个属性</strong>， <code>Proxy</code>  只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，递归还是需要进行的。此外 ** <code>Proxy</code>  支持代理数组的变化。**</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟视图的更新&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;前端工匠&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: &#123; <span class="attr">age</span>: <span class="number">100</span> &#125;,</span><br><span class="line">  <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果取的值是对象就在对这个对象进行数据劫持</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target[key] == <span class="string">&#x27;object&#x27;</span> &amp;&amp; target[key] !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target[key], handler)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;length&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="title function_">render</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, handler)</span><br><span class="line">proxy.<span class="property">age</span>.<span class="property">name</span> = <span class="string">&#x27;浪里行舟&#x27;</span> <span class="comment">// 支持新增属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">age</span>.<span class="property">name</span>) <span class="comment">// 模拟视图的更新 浪里行舟</span></span><br><span class="line">proxy.<span class="property">arr</span>[<span class="number">0</span>] = <span class="string">&#x27;浪里行舟&#x27;</span> <span class="comment">//支持数组的内容发生变化</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">arr</span>) <span class="comment">// 模拟视图的更新 [&#x27;浪里行舟&#x27;, 2, 3 ]</span></span><br><span class="line">proxy.<span class="property">arr</span>.<span class="property">length</span>-- <span class="comment">// 无效</span></span><br></pre></td></tr></table></figure></p>
<p>getter 用来收集依赖 setter 用来监听变换改变视图。收集完依赖需要为依赖找一个存储依赖的地方，为此我们创建了 Dep, 它用来收集依赖、删除依赖和向依赖发送消息等。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> () &#123;</span><br><span class="line">        <span class="comment">/* 用来存放Watcher对象的数组 */</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 在subs中添加一个Watcher对象 */</span></span><br><span class="line">    addSub (sub) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 通知所有Watcher对象更新视图 */</span></span><br><span class="line">    notify () &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">sub</span>) =&gt;</span> &#123;</span><br><span class="line">            sub.<span class="title function_">update</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="vue实现双向绑定"><a class="anchor" href="#vue实现双向绑定">#</a> vue 实现双向绑定</h2>
<p>vue 实现双向绑定是基于数据响应式。通过 <code>Object.defineProperty()</code>  来劫持各个属性的 <code>setter， getter</code> ，在数据发生变动时通知 Vue 实例，触发相应的 getter 和 setter 回调函数。vue 中的 v-model 是 v-on 和 v-bind 的语法糖。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;xxx&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 上面的代码等价于 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;xxx&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;xxx = $event.target.value&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 双向绑定 = 单向绑定 + UI事件监听 --&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>:value 实现单向绑定，@input 绑定事件从而实现双向绑定</p>
<p>要实现一个完整的双向绑定需要以下几个要点：</p>
<ol>
<li>利用 <code>Proxy</code>  或 <code>Object.defineProperty</code>  生成的 <code>Observer</code>  针对对象 / 对象的属性进行 &quot;劫持&quot;, 在属性发生变化后通知订阅者</li>
<li>解析器 <code>Compile</code>  解析模板中的 <code>Directive</code>  (指令)，收集指令所依赖的方法和数据，等待数据变化然后进行渲染</li>
<li><code>Watcher</code>  属于 <code>Observer</code>  和 <code>Compile</code>  桥梁，它将接收到的 <code>Observer</code>  产生的数据变化，并根据 <code>Compile</code>  提供的指令进行视图渲染，使得数据变化促使视图变化</li>
</ol>
<h2 id="vue如何解决跨域问题"><a class="anchor" href="#vue如何解决跨域问题">#</a> vue 如何解决跨域问题</h2>
<p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p>
<p>所谓同源（即指在同一个域）具有以下三个相同点</p>
<ul>
<li>
<p>协议相同（protocol）</p>
</li>
<li>
<p>主机相同（host）</p>
</li>
<li>
<p>端口相同（port）</p>
<p><strong>方案一 (proxy 代理)</strong></p>
<p>如果是通过 <code>vue-cli</code>  脚手架工具搭建项目，我们可以通过 <code>webpack</code>  为我们起一个本地服务器作为请求的代理对象</p>
<p>在 <code>vue.config.js</code>  文件，新增以下代码</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">amodule.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8084</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,<span class="comment">// vue项目启动时自动打开浏览器</span></span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123; <span class="comment">// &#x27;/api&#x27;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span><br><span class="line">                <span class="attr">target</span>: <span class="string">&quot;http://xxx.xxx.xx.xx:8080&quot;</span>, <span class="comment">//目标地址，一般是指后台服务器地址</span></span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//是否跨域</span></span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123; <span class="comment">// pathRewrite 的作用是把实际Request Url中的&#x27;/api&#x27;用&quot;&quot;代替</span></span><br><span class="line">                    <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&quot;&quot;</span> </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是生产环境可以配置 nginx 的代理和上述方式类似</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen    <span class="number">80</span>;</span><br><span class="line">    # server_name www.<span class="property">josephxia</span>.<span class="property">com</span>;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root  /<span class="keyword">var</span>/www/html;</span><br><span class="line">        index  index.<span class="property">html</span> index.<span class="property">htm</span>;</span><br><span class="line">        try_files $uri $uri/ /index.<span class="property">html</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    location /api &#123;</span><br><span class="line">        proxy_pass  <span class="attr">http</span>:<span class="comment">//127.0.0.1:3000;</span></span><br><span class="line">        proxy_redirect   off;</span><br><span class="line">        proxy_set_header  <span class="title class_">Host</span>       $host;</span><br><span class="line">        proxy_set_header  X-<span class="title class_">Real</span>-<span class="variable constant_">IP</span>     $remote_addr;</span><br><span class="line">        proxy_set_header  X-<span class="title class_">Forwarded</span>-<span class="title class_">For</span>  $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方案二 (CORS)</strong></p>
<p>它由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</p>
<p>后端在接受前端请求后先前端发送数据时在 http 请求头中直接设置 <code>Access-Control-Allow-Origin</code>  响应头如：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next)=&gt; &#123;</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#x27;</span>);</span><br><span class="line">  ctx.<span class="title function_">set</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (ctx.<span class="property">method</span> == <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="number">200</span>; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><strong>方案三 (JSONP)</strong></p>
<p>事先定义一个用于获取跨域响应数据的回调函数，并通过没有同源策略限制的 <code>script</code>  标签发起一个请求（将回调函数的名称放到这个请求的 <code>query</code>  参数里），然后服务端返回这个回调函数的执行，并将需要响应的数据放到回调函数的参数里，</p>
<p>优点</p>
<ul>
<li>
<p>它不像 <code>XMLHttpRequest</code>  对象实现的 <code>Ajax</code>  请求那样受到同源策略的限制</p>
</li>
<li>
<p>它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 <code>XMLHttpRequest</code>  或 <code>ActiveX</code>  的支持</p>
</li>
<li>
<p>并且在请求完毕后可以通过调用 <code>callback</code>  的方式回传结果</p>
<p>用 jsonp 的好处是可以单独让一个 http 请求跨域</p>
</li>
</ul>
<p>缺点：</p>
<p>​	它<strong>只支持 <code>GET</code>  请求</strong>而不支持  <code>POST</code>  等其它类型的 HTTP 请求</p>
</li>
</ul>
<h2 id="vue的diff算法"><a class="anchor" href="#vue的diff算法">#</a> vue 的 diff 算法</h2>
<p><code>diff</code>  算法是一种通过同层的树节点进行比较的高效算法</p>
<p>其有两个特点：</p>
<ul>
<li>
<p>比较只会在同层级进行，不会跨层级比较</p>
</li>
<li>
<p>在 diff 比较的过程中，循环从两边向中间比较</p>
<p>当数据发生改变时， <code>set</code>  方法会调用 <code>Dep.notify</code>  通知所有订阅者 <code>Watcher</code> ，订阅者就会调用 <code>patch</code>  给真实的 <code>DOM</code>  打补丁，更新相应的视图</p>
</li>
<li>
<p>当数据发生改变时，订阅者 <code>watcher</code>  就会调用 <code>patch</code>  给真实的 <code>DOM</code>  打补丁</p>
</li>
<li>
<p>通过 <code>isSameVnode</code>  进行判断，相同则调用 <code>patchVnode</code>  方法</p>
<p>patchVnode 做了以下操作：</p>
<p>找到对应的真实 <code>dom</code> ，称为 <code>el</code></p>
<ul>
<li>如果都有都有文本节点且不相等，将 <code>el</code>  文本节点设置为 <code>Vnode</code>  的文本节点</li>
<li>如果 <code>oldVnode</code>  有子节点而 <code>VNode</code>  没有，则删除 <code>el</code>  子节点</li>
<li>如果 <code>oldVnode</code>  没有子节点而 <code>VNode</code>  有，则将 <code>VNode</code>  的子节点真实化后添加到 <code>el</code></li>
<li>如果两者都有子节点，则执行 <code>updateChildren</code>  函数比较子节点</li>
</ul>
<p>updateChildren 主要做了以下操作：</p>
<ul>
<li>
<p>设置新旧 <code>VNode</code>  的头尾指针</p>
</li>
<li>
<p>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用 <code>patchVnode</code>  进行 <code>patch</code>  重复流程、调用 <code>createElem</code>  创建一个新节点，从哈希表寻找  <code>key</code>  一致的 <code>VNode</code>  节点再分情况操作</p>
<p><code>diff</code>  算法是一种通过同层的树节点进行比较的高效算法</p>
</li>
</ul>
</li>
</ul>
<h2 id="vue2和vue3的区别"><a class="anchor" href="#vue2和vue3的区别">#</a> vue2 和 vue3 的区别</h2>
<ul>
<li>响应式原理 api 的改变<br />
 Vue2 响应式原理采用的是 defineProperty，而 vue3 选用的是 proxy。这两者前者是修改对象属性的权限标签，后者是代理整个对象。性能上 proxy 会更加优秀。</li>
<li>diff 算法，渲染算法的改变<br />
 Vue3 优化 diff 算法。不再像 vue2 那样比对所有 dom，而采用了 block tree 的做法。此外重新渲染的算法里也做了改进，利用了闭包来进行缓存。这使得 vue3 的速度比 vue2 快了 6 倍。</li>
<li>建立数据 data<br />
 这里就是 Vue2 与 Vue3 最大的区别 — Vue2 使用 <code>选项类型API（Options API）</code> 对比 Vue3 <code>合成型API（Composition API）</code>  旧的选项型 API 在代码里分割了不同的属性（properties）：data，computed 属性，methods，等等。新的合成型 API 能让我们用方法（function）来分割，相比于旧的 API 使用属性来分组，这样代码会更加简便和整洁。</li>
<li>**Diff 算法重写：** 新增了最长递归子序列的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020">算法</a>，来计算出最小的修改偏移量。还增加了静态标记</li>
</ul>
<h2 id="v-show与v-if的区别"><a class="anchor" href="#v-show与v-if的区别">#</a> v-show 与 v-if 的区别</h2>
<p>控制手段： <code>v-show</code>  隐藏则是为该元素添加 <code>css--display:none</code> ， <code>dom</code>  元素依旧还在。 <code>v-if</code>  显示隐藏是将 <code>dom</code>  元素整个添加或删除</p>
<p>编译过程： <code>v-if</code>  切换有一个局部编译 / 卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件； <code>v-show</code>  只是简单的基于 css 切换</p>
<p>v-show 有 <code>transition</code>  就执行 <code>transition</code> ，没有就直接设置 <code>display</code>  属性</p>
<p>返回一个 <code>node</code>  节点， <code>render</code>  函数通过表达式的值来决定是否生成 <code>DOM</code></p>
<h2 id="前端性能优化"><a class="anchor" href="#前端性能优化">#</a> 前端性能优化</h2>
<ul>
<li>
<p><code>减少HTTP请求</code> <br />
如 Chrome 浏览器最多同时允许对同一个域名 Host 建立 6 个 TCP 连接，不同的浏览器有所区别，减少 http 请求也就是减少我们 html 里 css/js 等资源的数量</p>
</li>
<li>
<p><code>设置浏览器缓存策略</code> 主要为设置缓存策略：</p>
<ul>
<li>
<p>强制缓存：当 web 应用获取资源时，先从 本地 获取，如果有就直接用。强制缓存涉及到的头字段有  <code>Expires</code> （http1.0）和 <code>Cache-Control</code>  (http1.1)，由服务端设置.</p>
</li>
<li>
<p>Expires 接受一个 GMT 格式时间</p>
</li>
<li>
<figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token literal-property property">Expires</span><span class="token operator">:</span> Wed<span class="token punctuation">,</span> <span class="token number">21</span> Oct <span class="token number">2015</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">28</span><span class="token operator">:</span><span class="token number">00</span> <span class="token constant">GMT</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>code￼<span class="token number">7</span><span class="token operator">--</span><span class="token operator">></span></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><code>createElement</code>  创建  <code>VNode</code>  的过程，每个  <code>VNode</code>  有  <code>children</code> ， <code>children</code>  每个元素也是一个 <code>VNode</code> ，这样就形成了一个虚拟树结构，用于描述真实的 <code>DOM</code>  树结构</p>
<h2 id="组件间通信的方案"><a class="anchor" href="#组件间通信的方案">#</a> 组件间通信的方案</h2>
<ol>
<li>
<p>通过 props 传递</p>
<ul>
<li>适用场景：父组件传递数据给子组件</li>
<li>子组件设置 <code>props</code>  属性，定义接收父组件传递过来的参数，父组件在使用子组件标签中通过字面量来传递值</li>
</ul>
</li>
<li>
<p>通过 $emit 触发自定义事件</p>
<ul>
<li>适用场景：子组件传递数据给父组件</li>
<li>子组件通过 <code>$emit触发</code> 自定义事件， <code>$emit</code>  第二个参数为传递的数值，父组件绑定监听器获取到子组件传递过来的参数</li>
</ul>
</li>
<li>
<p>EventBus</p>
<ul>
<li>使用场景：兄弟组件传值</li>
<li>创建一个中央事件总线 <code>EventBus</code></li>
<li>兄弟组件通过 <code>$emit</code>  触发自定义事件， <code>$emit</code>  第二个参数为传递的数值，另一个兄弟组件通过 <code>$on</code>  监听自定义事件</li>
</ul>
</li>
<li>
<p>Provide 与 Inject</p>
<ol>
<li>
<p>在祖先组件定义 <code>provide</code>  属性，返回传递的值</p>
</li>
<li>
<p>在后代组件通过 <code>inject</code>  接收组件传递过来的值</p>
</li>
<li>
<figure class="highlight js"><figcaption data-lang="JavaScript"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  </pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>  </pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token literal-property property">foo</span><span class="token operator">:</span><span class="token string">'foo'</span>  </pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span>  </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span>  </pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token literal-property property">inject</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span> <span class="token comment">// 获取到祖先组件传递过来的值</span></pre></td></tr></table></figure></li>
</ol>
</li>
<li>
<p>Vuex</p>
</li>
</ol>
<h2 id="vue中key的原理吗"><a class="anchor" href="#vue中key的原理吗">#</a> vue 中 key 的原理吗</h2>
<ol>
<li>当我们在使用 <code>v-for</code>  时，需要给单元加上 <code>key</code></li>
</ol>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>用 <code>+new Date()</code>  生成的时间戳作为 <code>key</code> ，手动强制触发重新渲染</li>
</ol>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Comp</span> :key=<span class="string">&quot;+new Date()&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>在不使用 <code>key</code>  的情况，vue 会原地复用修改 DOM 值增加 DOM 操作</p>
<p>设置 key 值不一定能提高 diff 效率。</p>
</div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">更新于</span><time title="修改时间：2024-05-28 20:22:22" itemprop="dateModified" datetime="2024-05-28T20:22:22+08:00">2024-05-28</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i>赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img loading="lazy" data-src="/assets/wechatpay.png" alt="TechVoy 微信支付"/><p>微信支付</p></div><div><img loading="lazy" data-src="/assets/alipay.png" alt="TechVoy 支付宝"/><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者：</strong>TechVoy<i class="ic i-at"><em>@</em></i>worked warriors</li><li class="link"><strong>本文链接：</strong><a href="http://example.com/2024/05/28/vue%E7%B3%BB%E5%88%97/" title="vue系列">http://example.com/2024/05/28/vue系列/</a></li><li class="license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/05/27/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/" rel="prev" itemprop="url" data-background-image="https:&#x2F;&#x2F;img2.imgtp.com&#x2F;2024&#x2F;05&#x2F;28&#x2F;aur7gBvM.jpg" title="腾讯一面"><span class="type">上一篇</span><span class="category"><i class="ic i-flag"></i>面试记录</span><h3>腾讯一面</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#vue%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text"> vue 相关面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.</span> <span class="toc-text"> vue 的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text"> vue 的响应式原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951objectdefineproperty%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 方法 1.Object.defineProperty 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952proxy%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 方法 2.Proxy 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">1.3.</span> <span class="toc-text"> vue 实现双向绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text"> vue 如何解决跨域问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E7%9A%84diff%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text"> vue 的 diff 算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue2%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text"> vue2 和 vue3 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-show%E4%B8%8Ev-if%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text"> v-show 与 v-if 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.8.</span> <span class="toc-text"> 前端性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">1.9.</span> <span class="toc-text"> 组件间通信的方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%B8%ADkey%E7%9A%84%E5%8E%9F%E7%90%86%E5%90%97"><span class="toc-number">1.10.</span> <span class="toc-text"> vue 中 key 的原理吗</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li  class="active"><a href="/2024/05/28/vue%E7%B3%BB%E5%88%97/" rel="bookmark" title="vue系列">vue系列</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="TechVoy" src="/assets/avatar.jpg"/><p class="name" itemprop="name">TechVoy</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">2</span><span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">3</span><span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">2</span><span class="name">标签</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/wxchdu" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;wxchdu"><i class="ic i-github"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-coffee"></i>关于</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-user"></i>文章</a><ul class="submenu"><li class="item"><a href="/categories/" rel="section"><i class="ic i-user"></i>分类</a></li><li class="item"><a href="/tag/" rel="section"><i class="ic i-cloud"></i>标签</a></li></ul></li></div></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/05/27/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/study/" title="分类于平时学习">平时学习</a></div><span><a href="/2024/05/28/vue%E7%B3%BB%E5%88%97/">vue系列</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/" title="分类于面试记录">面试记录</a></div><span><a href="/2024/05/27/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/">腾讯一面</a></span></li></ul></div><div class="rpost pjax"><h2>最新评论</h2></div></div><div class="status"><div class="copyright">&copy; 2010 -<span itemprop="copyrightYear">2024</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">TechVoy @ TechVoy's blog</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="站点总字数">12k 字</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="站点阅读时长">11 分钟</span></div><div class="powered-by">基于 <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
        path: `2024/05/28/vue系列/`,
        favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "文章搜索",
        empty: "关于 「 ${query} 」，什么也没搜到",
        stats: "${time} ms 内找到 ${hits} 条结果"
    },
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">文章时效性提示</span><br>这是一篇发布于 {{publish}} 天前，最后一次更新在 {{updated}} 天前的文章，部分信息可能已经发生改变，请注意甄别。</p></div>`,
    quiz: {
        choice: `单选题`,
        multiple: `多选题`,
        true_false: `判断题`,
        essay: `问答题`,
        gap_fill: `填空题`,
        mistake: `错题备注`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-6-M/pace/1.2.4/pace.min.js" async></script><script src="/js/siteInit.js?v=0.4.2" type="module" fetchpriority="high" defer></script></body></html>