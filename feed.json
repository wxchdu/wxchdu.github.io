{
    "version": "https://jsonfeed.org/version/1",
    "title": "worked warriors",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/05/29/TS%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/",
            "url": "http://example.com/2024/05/29/TS%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/",
            "title": "TS学习记录",
            "date_published": "2024-05-29T01:12:48.000Z",
            "content_html": "<h1 id=\"typescript的内置数据类型有哪些\"><a class=\"anchor\" href=\"#typescript的内置数据类型有哪些\">#</a> TypeScript 的内置数据类型有哪些？</h1>\n<p>在 Typescript 中，内置的数据类型也称为原始数据类型。</p>\n<p>boolean（布尔类型）</p>\n<p>number（数字类型）</p>\n<p>string（字符串类型）</p>\n<p>void 类型</p>\n<p>null 和 undefined 类型</p>\n<p>array（数组类型）</p>\n<p>tuple（元组类型）：允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p>\n<p>enum（枚举类型）： <code>enum</code>  类型是对 JavaScript 标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p>\n<p>any（任意类型）</p>\n<p>never 类型</p>\n<p>object 对象类型</p>\n<p>unknown 是一个类型安全的 any，不能直接赋值给其他类型的变量，如果要赋值需要先做判断，或者使用断言</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span>:<span class=\"built_in\">unknown</span>;</span><br><span class=\"line\">a=<span class=\"string\">&quot;123&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">b = a <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure></p>\n<p>void 表示返回空，可以返回 null 或 undefined，never 表示没有返回值，null 和 undefined 也不能返回</p>\n<p>object 表示对象类型但经常是指定对象类型的如</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a : &#123;<span class=\"attr\">name</span>:<span class=\"built_in\">string</span>&#125;;</span><br><span class=\"line\">a=&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;xunwukong&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果想定义多个属性名可以：</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">b</span>:&#123;<span class=\"attr\">name</span>:<span class=\"built_in\">string</span>,[<span class=\"attr\">prop</span>:<span class=\"built_in\">string</span>]:<span class=\"built_in\">string</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">b=&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;zhubaje&quot;</span>,<span class=\"attr\">gendle</span>:<span class=\"string\">&quot;nan&quot;</span>,<span class=\"attr\">age</span>:<span class=\"string\">&quot;18&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>prop:string 表示属性名的类型，：sting 表示属性值的类型。</p>\n<p>同样，还可以定义函数：</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> c : <span class=\"function\">(<span class=\"params\">a:<span class=\"built_in\">number</span>,b:<span class=\"built_in\">number</span></span>)=&gt;</span><span class=\"built_in\">number</span>;</span><br><span class=\"line\">c = <span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可以定义数组：</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> d : <span class=\"built_in\">string</span>[];</span><br></pre></td></tr></table></figure></p>\n<p>tuple 表示固定类型和长度的数组，类型和长度不能变</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> e : [<span class=\"built_in\">string</span>,<span class=\"built_in\">number</span>];</span><br><span class=\"line\">e = [<span class=\"string\">&quot;hello&quot;</span>,<span class=\"number\">123</span>];</span><br></pre></td></tr></table></figure></p>\n<p>enum 表示枚举类型，用于赋予友好的名字</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Gneder</span>&#123;</span><br><span class=\"line\">  male=<span class=\"number\">0</span>,</span><br><span class=\"line\">  female=<span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> f : &#123;<span class=\"attr\">name</span>: <span class=\"built_in\">string</span>,<span class=\"attr\">gender</span>:<span class=\"title class_\">Gneder</span>&#125;;</span><br><span class=\"line\">f = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;xunwukong&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">gender</span>: <span class=\"title class_\">Gneder</span>.<span class=\"property\">male</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>类型可以起别名用于简化</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> myType = <span class=\"number\">1</span>|<span class=\"number\">2</span>|<span class=\"number\">3</span>|<span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">g</span>:myType;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"ts的配置文件\"><a class=\"anchor\" href=\"#ts的配置文件\">#</a> ts 的配置文件</h1>\n<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>如果一个目录下存在一个 <code>tsconfig.json</code>  文件，那么它意味着这个目录是 TypeScript 项目的根目录。  <code>tsconfig.json</code>  文件中指定了用来编译这个项目的根文件和编译选项。 一个项目可以通过以下方式之一来编译：</p>\n<ul>\n<li>\n<p>使用 <code>&quot;include&quot;</code>  和 <code>&quot;exclude&quot;</code>  属性</p>\n<p><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;outDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./built&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;allowJs&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;es5&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;include&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;./src/**/*&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<p>include 用来包含那些文件 ** 表示任意目录，* 表示任意文件</p>\n<p>compilerOptions 表示编译选项</p>\n<p>有很多</p>\n<p><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;incremental&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度</span></span><br><span class=\"line\"><span class=\"attr\">&quot;tsBuildInfoFile&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./buildFile&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 增量编译文件的存储位置</span></span><br><span class=\"line\"><span class=\"attr\">&quot;diagnostics&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 打印诊断信息 </span></span><br><span class=\"line\"><span class=\"attr\">&quot;target&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ES5&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 目标语言的版本</span></span><br><span class=\"line\"><span class=\"attr\">&quot;module&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;CommonJS&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 生成代码的模板标准</span></span><br><span class=\"line\">                 <span class=\"comment\">// 默认值 target === &quot;es3&quot; or &quot;es5&quot; ?&quot;commonjs&quot; : &quot;es6&quot;</span></span><br><span class=\"line\"><span class=\"attr\">&quot;outFile&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./app.js&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，</span></span><br><span class=\"line\">                      <span class=\"comment\">// 即开启时应设置&quot;module&quot;: &quot;AMD&quot;,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;lib&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 编译时引入的 ES 功能库，包括：es5 、es6、es7、dom 等。// 如果未设置，则默认为： target 为 es5 时: [&quot;dom&quot;, &quot;es5&quot;, &quot;scripthost&quot;] </span></span><br><span class=\"line\"><span class=\"comment\">//target 为 es6 时: [&quot;dom&quot;, &quot;es6&quot;, &quot;dom.iterable&quot;, &quot;scripthost&quot;]</span></span><br><span class=\"line\"><span class=\"attr\">&quot;allowJS&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 允许编译器编译JS，JSX文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;checkJs&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 允许在JS文件中报错，通常与allowJS一起使用</span></span><br><span class=\"line\"><span class=\"attr\">&quot;outDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./dist&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 指定输出目录</span></span><br><span class=\"line\"><span class=\"attr\">&quot;rootDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 指定输出文件目录(用于输出)，用于控制输出目录结构</span></span><br><span class=\"line\"><span class=\"attr\">&quot;declaration&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 生成声明文件，开启后会自动生成声明文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;declarationDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./file&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 指定生成声明文件存放目录</span></span><br><span class=\"line\"><span class=\"attr\">&quot;emitDeclarationOnly&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 只生成声明文件，而不会生成js文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;sourceMap&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 生成目标文件的sourceMap文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;inlineSourceMap&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 生成目标文件的inline SourceMap，//inline SourceMap会包含在生成的js文件中</span></span><br><span class=\"line\"><span class=\"attr\">&quot;declarationMap&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 为声明文件生成sourceMap</span></span><br><span class=\"line\"><span class=\"attr\">&quot;typeRoots&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 声明文件目录，默认时node_modules/@types</span></span><br><span class=\"line\"><span class=\"attr\">&quot;types&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 加载的声明文件包</span></span><br><span class=\"line\">              <span class=\"comment\">//如果指定了某个值， 她会在 typeRoots 下找这个包，找到了就只加载这个包</span></span><br><span class=\"line\"><span class=\"attr\">&quot;removeComments&quot;</span><span class=\"punctuation\">:</span><span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 删除注释 </span></span><br><span class=\"line\"><span class=\"attr\">&quot;noEmit&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 不输出文件,即编译后不会生成任何js文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noEmitOnError&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 发送错误时不输出任何文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noEmitHelpers&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用</span></span><br><span class=\"line\"><span class=\"attr\">&quot;importHelpers&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 通过tslib引入helper函数，文件必须是模块</span></span><br><span class=\"line\"><span class=\"attr\">&quot;downlevelIteration&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现</span></span><br><span class=\"line\"><span class=\"attr\">&quot;strict&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 开启所有严格的类型检查</span></span><br><span class=\"line\"><span class=\"attr\">&quot;alwaysStrict&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 在代码中注入&#x27;use strict&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noImplicitAny&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 不允许隐式的any类型</span></span><br><span class=\"line\"><span class=\"attr\">&quot;strictNullChecks&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 不允许把null、undefined赋值给其他类型的变量</span></span><br><span class=\"line\"><span class=\"attr\">&quot;strictFunctionTypes&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 不允许函数参数双向协变</span></span><br><span class=\"line\"><span class=\"attr\">&quot;strictPropertyInitialization&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 类的实例属性必须初始化</span></span><br><span class=\"line\"><span class=\"attr\">&quot;strictBindCallApply&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 严格的bind/call/apply检查</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noImplicitThis&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 不允许this有隐式的any类型</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noUnusedLocals&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 检查只声明、未使用的局部变量(只提示不报错)</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noUnusedParameters&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 检查未使用的函数参数(只提示不报错)</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noFallthroughCasesInSwitch&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 防止switch语句贯穿(即如果没有break语句后面不会执行)</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noImplicitReturns&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">//每个分支都会有返回值</span></span><br><span class=\"line\"><span class=\"attr\">&quot;esModuleInterop&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 允许export=导出，由import from 导入</span></span><br><span class=\"line\"><span class=\"attr\">&quot;allowUmdGlobalAccess&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 允许在模块中全局变量的方式访问umd模块</span></span><br><span class=\"line\"><span class=\"attr\">&quot;moduleResolution&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;node&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 模块解析策略，ts默认用node的解析策略，即相对的方式导入</span></span><br><span class=\"line\"><span class=\"attr\">&quot;baseUrl&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 解析非相对模块的基地址，默认是当前目录</span></span><br><span class=\"line\"><span class=\"attr\">&quot;paths&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span> <span class=\"comment\">// 路径映射，相对于baseUrl</span></span><br><span class=\"line\">    <span class=\"comment\">// 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;jquery&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;node_modules/jquery/dist/jquery.min.js&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;rootDirs&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;src&quot;</span><span class=\"punctuation\">,</span><span class=\"string\">&quot;out&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 将多个目录放在一个虚拟目录下，用于运行时，</span></span><br><span class=\"line\">                          <span class=\"comment\">//即编译后引入文件的位置可能发生变化，</span></span><br><span class=\"line\">                          <span class=\"comment\">//这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错</span></span><br><span class=\"line\"><span class=\"attr\">&quot;listEmittedFiles&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 打印输出文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;listFiles&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span> <span class=\"punctuation\">,</span> <span class=\"comment\">// 打印编译的文件(包括引用的声明文件)</span></span><br><span class=\"line\"><span class=\"attr\">&quot;jsx&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;Preserve&quot;</span>   <span class=\"comment\">//在 .tsx 中支持 JSX ：React 或 Preserve</span></span><br><span class=\"line\"><span class=\"attr\">&quot;jsxFactory&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;&quot;</span>   <span class=\"comment\">//默认值 React.createElement\t。  jsx 设置为 React 时使用的创建函数</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"typescript-中-const-和-readonly-的区别枚举和常量枚举的区别接口和类型别名的区别\"><a class=\"anchor\" href=\"#typescript-中-const-和-readonly-的区别枚举和常量枚举的区别接口和类型别名的区别\">#</a> <strong>TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？</strong></h1>\n<p><code>const 和 readonly</code> : const 可以防止变量的值被修改，readonly 关键字用于定义类中的只读属性。只读属性只能在声明时或构造函数中进行赋值，后续不能对其进行修改。</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PI</span> = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable constant_\">PI</span>); <span class=\"comment\">// 输出: 3.14</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable constant_\">PI</span> = <span class=\"number\">3.14159</span>; <span class=\"comment\">// 报错: &quot;Cannot assign to &#x27;PI&#x27; because it is a constant.&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">changeName</span>(<span class=\"params\">newName: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = newName; <span class=\"comment\">// 报错: &quot;Cannot assign to &#x27;name&#x27; because it is a read-only property.&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;Alice&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person.<span class=\"property\">name</span>); <span class=\"comment\">// 输出: &quot;Alice&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">&#x27;Bob&#x27;</span>; <span class=\"comment\">// 报错: &quot;Cannot assign to &#x27;name&#x27; because it is a read-only property.&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p><code>枚举和常量枚举</code> ：常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。<br />\n <code>接口和类型别名</code> ：两者都可以用来描述对象或函数的类型。相同点：<br />\n\\1. 都可以描述 ' 对象 ' 或者 ' 函数'<br />\n\\2. 都允许拓展 (extends)</p>\n<p>不同点：<br />\n\\1. type 可以声明基本类型，联合类型，元组<br />\n \\2. type 可以使用 typeof 获取实例的类型进行赋值<br />\n \\3. 多个相同的 interface 声明可以自动合并</p>\n<p>与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。接口可用来实现，某个类可以实现接口，实现接口中所有的抽象类和方法</p>\n<h1 id=\"typescript-中-interface-可以给-function-array-classindexable做声明\"><a class=\"anchor\" href=\"#typescript-中-interface-可以给-function-array-classindexable做声明\">#</a> TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明</h1>\n<p>可以声明函数，数组，类</p>\n<blockquote>\n<p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 可以 */</span></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\">interface <span class=\"title class_\">Say</span> &#123;</span><br><span class=\"line\"> (<span class=\"attr\">name</span>: string): viod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">say</span>: <span class=\"title class_\">Say</span> = (<span class=\"attr\">name</span>: string):<span class=\"function\"><span class=\"params\">viod</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// Array 声明</span></span><br><span class=\"line\">interface <span class=\"title class_\">NumberArray</span> &#123; </span><br><span class=\"line\"> [<span class=\"attr\">index</span>: number]: number; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">fibonacci</span>: <span class=\"title class_\">NumberArray</span> = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"comment\">// Class 声明</span></span><br><span class=\"line\">interface <span class=\"title class_\">PersonalIntl</span> &#123;</span><br><span class=\"line\"> <span class=\"attr\">name</span>: string</span><br><span class=\"line\"> sayHi (<span class=\"attr\">name</span>: string): string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"typescript-如何设计-class-的声明\"><a class=\"anchor\" href=\"#typescript-如何设计-class-的声明\">#</a> TypeScript 如何设计 Class 的声明？</h1>\n<p>在类中声明属性或方法，使用 constructor 构造函数赋予初值</p>\n<blockquote>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Greeter</span> &#123;</span><br><span class=\"line\">   <span class=\"attr\">greeting</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">   <span class=\"title function_\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">       <span class=\"variable language_\">this</span>.<span class=\"property\">greeting</span> = message;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"title function_\">greet</span>(): <span class=\"built_in\">string</span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">greeting</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter = <span class=\"keyword\">new</span> <span class=\"title class_\">Greeter</span>(<span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 在声明类的时候，一般类中都会包含，构造函数、对构造函数中的属性进行类型声明、类中的方法。</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"typescript-中如何设置模块导入的路径别名\"><a class=\"anchor\" href=\"#typescript-中如何设置模块导入的路径别名\">#</a> TypeScript 中如何设置模块导入的路径别名？</h1>\n<blockquote>\n<p>通过 tsconfig.json 中的 paths 项来配置:</p>\n<p><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;baseUrl&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;.&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">      <span class=\"attr\">&quot;paths&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">         <span class=\"attr\">&quot;@helper/*&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;src/helper/*&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">         <span class=\"attr\">&quot;@utils/*&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;src/utils/*&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">         ... </span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span> </span><br><span class=\"line\">   <span class=\"punctuation\">&#125;</span> </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"对-typescript-类中成员的-public-private-protected-readonly-修饰符的理解\"><a class=\"anchor\" href=\"#对-typescript-类中成员的-public-private-protected-readonly-修饰符的理解\">#</a> 对 TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解？</h1>\n<blockquote>\n<p><code>public</code> : 成员都默认为 <code>public</code> ，被此限定符修饰的成员是可以被外部访问；<br />\n <code>private</code> : 被此限定符修饰的成员是只可以被类的内部访问；<br />\n <code>protected</code> : 被此限定符修饰的成员是只可以被类的内部以及类的子类访问；<br />\n <code>readonly</code> : 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>\n</blockquote>\n<h1 id=\"数组定义的两种方式\"><a class=\"anchor\" href=\"#数组定义的两种方式\">#</a> 数组定义的两种方式</h1>\n<blockquote>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span>= <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Bar</span> &#123; </span><br><span class=\"line\">     <span class=\"attr\">baz</span>: <span class=\"title class_\">Array</span>&lt;&#123; <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>&#125;&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = <span class=\"built_in\">string</span>[];</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Bar</span> &#123; </span><br><span class=\"line\">     baz : &#123; <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">age</span>: <span class=\"built_in\">number</span> &#125;[] </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"ts中的泛型是什么\"><a class=\"anchor\" href=\"#ts中的泛型是什么\">#</a> TS 中的泛型是什么？</h1>\n<p>泛型允许我们在编写代码时使用一些以后才指定的类型，在定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性。</p>\n<p>any 和泛型的区别？</p>\n<p>泛型有类型推论，编译器会根据传入的参数自动地帮助我们确定 T 的类型</p>\n<p>any 则是不检验</p>\n<h1 id=\"类的静态成员\"><a class=\"anchor\" href=\"#类的静态成员\">#</a> 类的静态成员</h1>\n<p>在 TypeScript 中，类可以拥有静态成员，它们属于类本身，而不是属于类的实例。静态成员可以通过  <code>static</code>  关键字来定义。下面是一个使用静态成员的例子：</p>\n<p><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Calculator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"attr\">PI</span>: <span class=\"built_in\">number</span> = <span class=\"number\">3.1415926</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"title function_\">add</span>(<span class=\"attr\">x</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"title function_\">subtract</span>(<span class=\"attr\">x</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x - y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Calculator</span>.<span class=\"property\">PI</span>); <span class=\"comment\">// 输出：3.1415926</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Calculator</span>.<span class=\"title function_\">add</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)); <span class=\"comment\">// 输出：3</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Calculator</span>.<span class=\"title function_\">subtract</span>(<span class=\"number\">4</span>, <span class=\"number\">2</span>)); <span class=\"comment\">// 输出：2</span></span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，我们定义了一个  <code>Calculator</code>  类，它有一个静态属性  <code>PI</code>  和两个静态方法  <code>add</code>  和  <code>subtract</code> 。这些成员可以在任何地方被调用，无需创建  <code>Calculator</code>  类的实例。</p>\n<h1 id=\"简单介绍一下-typescript-模块的加载机制\"><a class=\"anchor\" href=\"#简单介绍一下-typescript-模块的加载机制\">#</a> 简单介绍一下 TypeScript 模块的加载机制？</h1>\n<p>假设有一个导入语句  <code>import &#123; a &#125; from &quot;moduleA&quot;</code> ;</p>\n<ol>\n<li>首先，编译器会尝试定位需要导入的模块文件，通过绝对或者相对的路径查找方式；</li>\n<li>如果上面的解析失败了，没有查找到对应的模块，编译器会尝试定位一个 <code>外部模块声明</code> （.d.ts）；</li>\n<li>最后，如果编译器还是不能解析这个模块，则会抛出一个错误  <code>error TS2307: Cannot find module 'moduleA'.</code></li>\n</ol>\n",
            "tags": [
                "学习，ts"
            ]
        },
        {
            "id": "http://example.com/2024/05/29/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/",
            "url": "http://example.com/2024/05/29/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/",
            "title": "常用命令",
            "date_published": "2024-05-29T01:12:48.000Z",
            "content_html": "<h1 id=\"npm镜像源\"><a class=\"anchor\" href=\"#npm镜像源\">#</a> npm 镜像源</h1>\n<p>使用<strong>淘宝</strong>镜像源加速 NPM</p>\n<p><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry <span class=\"attr\">https</span>:<span class=\"comment\">//registry.npmmirror.com</span></span><br></pre></td></tr></table></figure></p>\n<p>使用<strong>阿里云</strong> 镜像源加速 NPM</p>\n<p><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry <span class=\"attr\">https</span>:<span class=\"comment\">//npm.aliyun.com</span></span><br></pre></td></tr></table></figure></p>\n<p>返回<strong> npm 官方原始镜像</strong></p>\n<p><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry <span class=\"attr\">https</span>:<span class=\"comment\">//registry.npmjs.org/</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"ts相关命令\"><a class=\"anchor\" href=\"#ts相关命令\">#</a> ts 相关命令</h1>\n<p>使用  <code>npm</code>  进行安装</p>\n<p><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## Windows版</span></span><br><span class=\"line\"><span class=\"built_in\">npm</span> install -g typescript</span><br></pre></td></tr></table></figure></p>\n<p>ts 编译命令</p>\n<p>使用以下命令，逐个编译文件。</p>\n<p><figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">## 首先进入到上面文件的目录（cd xxxxxx)</span></span><br><span class=\"line\">tsc app.ts</span><br><span class=\"line\"><span class=\"meta\">## 使用-w可以监视编译    </span></span><br><span class=\"line\">tsc app.ts -w</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "工具"
            ]
        },
        {
            "id": "http://example.com/2024/05/28/vue%E7%B3%BB%E5%88%97/",
            "url": "http://example.com/2024/05/28/vue%E7%B3%BB%E5%88%97/",
            "title": "vue系列",
            "date_published": "2024-05-28T01:12:48.000Z",
            "content_html": "<h1 id=\"vue的生命周期\"><a class=\"anchor\" href=\"#vue的生命周期\">#</a> vue 的生命周期</h1>\n<p>​\tVue 生命周期总共可以分为 8 个阶段</p>\n<table>\n<thead>\n<tr>\n<th>beforeCreate</th>\n<th>组件实例被创建之初</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>created</td>\n<td>组件实例已经完全创建</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>组件挂载之前</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>组件挂载到实例上去之后</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>组件数据发生变化，更新之前</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>组件数据更新之后</td>\n</tr>\n<tr>\n<td>beforeDestroy</td>\n<td>组件实例销毁之前</td>\n</tr>\n<tr>\n<td>destroyed</td>\n<td>组件实例销毁之后</td>\n</tr>\n<tr>\n<td>activated</td>\n<td>keep-alive 缓存的组件激活时</td>\n</tr>\n<tr>\n<td>deactivated</td>\n<td>keep-alive 缓存的组件停用时调用</td>\n</tr>\n<tr>\n<td>errorCaptured</td>\n<td>捕获一个来自子孙组件的错误时被调用</td>\n</tr>\n</tbody>\n</table>\n<p>在 vue2 和 vue3 中的生命周期钩子函数有所不同：</p>\n<p>​\tvue3 中多了 setup 生命周期，所以 vue3 中的 created 和 beforecreate 换成了 setup，销毁换成了 onBeforeUnmount 和 onUnmounted。此外被包含在 &lt;keep-alive&gt; 中的组件，会多出两个生命周期钩子函数，被激活时执行 onActivated ，停用时执行 deactivated。</p>\n<h1 id=\"vue的响应式原理\"><a class=\"anchor\" href=\"#vue的响应式原理\">#</a> vue 的响应式原理</h1>\n<p>​\t在 vue2，和 vue3 中响应式原理时不同的。在 vue2 中使用的是 object.defineProperty 进行数据劫持的。</p>\n<h2 id=\"方法1objectdefineproperty实现\"><a class=\"anchor\" href=\"#方法1objectdefineproperty实现\">#</a> 方法 1.Object.defineProperty 实现</h2>\n<p>给数据赋予 <code>getter</code>  和 <code>setter</code> 。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> middle = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(data,<span class=\"string\">&#x27;age&#x27;</span>,&#123;</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;获取age&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">parmas</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//参数就是赋值的数据</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;修改age数据&#x27;</span>,parmas)</span><br><span class=\"line\">    middle = parmas</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span><br><span class=\"line\"><span class=\"comment\">// 取值的时候触发getter</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data.<span class=\"property\">age</span>)</span><br><span class=\"line\"><span class=\"comment\">//赋值的时候触发setter</span></span><br><span class=\"line\">data.<span class=\"property\">age</span> = <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data.<span class=\"property\">age</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>而每个 setter 方法就是一个观察者，在数据变更的时候通知订阅者更新视图。当数据发生变化时页面上的数据会实时改变，更新页面。但这种方法<strong>无法检测到对象属性的添加或删除</strong> (如 <code>data.location.a=1</code> )； <code>getter/setter</code>  只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。所以 ** <code>Object.defineProperty</code>  不能监听数组的变化，需要进行数组方法的重写 **</p>\n<h2 id=\"方法2proxy实现\"><a class=\"anchor\" href=\"#方法2proxy实现\">#</a> 方法 2.Proxy 实现</h2>\n<p>​\t <code>Proxy</code>  是 JavaScript 2015 的一个新特性。<strong> <code>Proxy</code>  的代理是针对整个对象的，而不是对象的某个属性</strong>， <code>Proxy</code>  只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，递归还是需要进行的。此外 ** <code>Proxy</code>  支持代理数组的变化。**</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;模拟视图的更新&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;前端工匠&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">100</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">arr</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果取的值是对象就在对这个对象进行数据劫持</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> target[key] == <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; target[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(target[key], handler)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, key)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">target, key, value</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;length&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, key, value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(obj, handler)</span><br><span class=\"line\">proxy.<span class=\"property\">age</span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;浪里行舟&#x27;</span> <span class=\"comment\">// 支持新增属性</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(proxy.<span class=\"property\">age</span>.<span class=\"property\">name</span>) <span class=\"comment\">// 模拟视图的更新 浪里行舟</span></span><br><span class=\"line\">proxy.<span class=\"property\">arr</span>[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;浪里行舟&#x27;</span> <span class=\"comment\">//支持数组的内容发生变化</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(proxy.<span class=\"property\">arr</span>) <span class=\"comment\">// 模拟视图的更新 [&#x27;浪里行舟&#x27;, 2, 3 ]</span></span><br><span class=\"line\">proxy.<span class=\"property\">arr</span>.<span class=\"property\">length</span>-- <span class=\"comment\">// 无效</span></span><br></pre></td></tr></table></figure></p>\n<p>getter 用来收集依赖 setter 用来监听变换改变视图。收集完依赖需要为依赖找一个存储依赖的地方，为此我们创建了 Dep, 它用来收集依赖、删除依赖和向依赖发送消息等。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dep</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 用来存放Watcher对象的数组 */</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span> = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 在subs中添加一个Watcher对象 */</span></span><br><span class=\"line\">    addSub (sub) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>.<span class=\"title function_\">push</span>(sub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 通知所有Watcher对象更新视图 */</span></span><br><span class=\"line\">    notify () &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">sub</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            sub.<span class=\"title function_\">update</span>();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"vue实现双向绑定\"><a class=\"anchor\" href=\"#vue实现双向绑定\">#</a> vue 实现双向绑定</h1>\n<p>vue 实现双向绑定是基于数据响应式。通过 <code>Object.defineProperty()</code>  来劫持各个属性的 <code>setter， getter</code> ，在数据发生变动时通知 Vue 实例，触发相应的 getter 和 setter 回调函数。vue 中的 v-model 是 v-on 和 v-bind 的语法糖。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=<span class=\"string\">&quot;xxx&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 上面的代码等价于 --&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">:value</span>=<span class=\"string\">&quot;xxx&quot;</span> @<span class=\"attr\">input</span>=<span class=\"string\">&quot;xxx = $event.target.value&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"comment\">&lt;!-- 双向绑定 = 单向绑定 + UI事件监听 --&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>:value 实现单向绑定，@input 绑定事件从而实现双向绑定</p>\n<p>要实现一个完整的双向绑定需要以下几个要点：</p>\n<ol>\n<li>利用 <code>Proxy</code>  或 <code>Object.defineProperty</code>  生成的 <code>Observer</code>  针对对象 / 对象的属性进行 &quot;劫持&quot;, 在属性发生变化后通知订阅者</li>\n<li>解析器 <code>Compile</code>  解析模板中的 <code>Directive</code>  (指令)，收集指令所依赖的方法和数据，等待数据变化然后进行渲染</li>\n<li><code>Watcher</code>  属于 <code>Observer</code>  和 <code>Compile</code>  桥梁，它将接收到的 <code>Observer</code>  产生的数据变化，并根据 <code>Compile</code>  提供的指令进行视图渲染，使得数据变化促使视图变化</li>\n</ol>\n<h1 id=\"vue如何解决跨域问题\"><a class=\"anchor\" href=\"#vue如何解决跨域问题\">#</a> vue 如何解决跨域问题</h1>\n<p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p>\n<p>所谓同源（即指在同一个域）具有以下三个相同点</p>\n<ul>\n<li>\n<p>协议相同（protocol）</p>\n</li>\n<li>\n<p>主机相同（host）</p>\n</li>\n<li>\n<p>端口相同（port）</p>\n<p><strong>方案一 (proxy 代理)</strong></p>\n<p>如果是通过 <code>vue-cli</code>  脚手架工具搭建项目，我们可以通过 <code>webpack</code>  为我们起一个本地服务器作为请求的代理对象</p>\n<p>在 <code>vue.config.js</code>  文件，新增以下代码</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">amodule.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">devServer</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">host</span>: <span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">port</span>: <span class=\"number\">8084</span>,</span><br><span class=\"line\">        <span class=\"attr\">open</span>: <span class=\"literal\">true</span>,<span class=\"comment\">// vue项目启动时自动打开浏览器</span></span><br><span class=\"line\">        <span class=\"attr\">proxy</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;/api&#x27;</span>: &#123; <span class=\"comment\">// &#x27;/api&#x27;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span><br><span class=\"line\">                <span class=\"attr\">target</span>: <span class=\"string\">&quot;http://xxx.xxx.xx.xx:8080&quot;</span>, <span class=\"comment\">//目标地址，一般是指后台服务器地址</span></span><br><span class=\"line\">                <span class=\"attr\">changeOrigin</span>: <span class=\"literal\">true</span>, <span class=\"comment\">//是否跨域</span></span><br><span class=\"line\">                <span class=\"attr\">pathRewrite</span>: &#123; <span class=\"comment\">// pathRewrite 的作用是把实际Request Url中的&#x27;/api&#x27;用&quot;&quot;代替</span></span><br><span class=\"line\">                    <span class=\"string\">&#x27;^/api&#x27;</span>: <span class=\"string\">&quot;&quot;</span> </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果是生产环境可以配置 nginx 的代理和上述方式类似</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen    <span class=\"number\">80</span>;</span><br><span class=\"line\">    # server_name www.<span class=\"property\">josephxia</span>.<span class=\"property\">com</span>;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root  /<span class=\"keyword\">var</span>/www/html;</span><br><span class=\"line\">        index  index.<span class=\"property\">html</span> index.<span class=\"property\">htm</span>;</span><br><span class=\"line\">        try_files $uri $uri/ /index.<span class=\"property\">html</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    location /api &#123;</span><br><span class=\"line\">        proxy_pass  <span class=\"attr\">http</span>:<span class=\"comment\">//127.0.0.1:3000;</span></span><br><span class=\"line\">        proxy_redirect   off;</span><br><span class=\"line\">        proxy_set_header  <span class=\"title class_\">Host</span>       $host;</span><br><span class=\"line\">        proxy_set_header  X-<span class=\"title class_\">Real</span>-<span class=\"variable constant_\">IP</span>     $remote_addr;</span><br><span class=\"line\">        proxy_set_header  X-<span class=\"title class_\">Forwarded</span>-<span class=\"title class_\">For</span>  $proxy_add_x_forwarded_for;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>方案二 (CORS)</strong></p>\n<p>它由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</p>\n<p>后端在接受前端请求后先前端发送数据时在 http 请求头中直接设置 <code>Access-Control-Allow-Origin</code>  响应头如：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"keyword\">async</span> (ctx, next)=&gt; &#123;</span><br><span class=\"line\">  ctx.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class=\"string\">&#x27;*&#x27;</span>);</span><br><span class=\"line\">  ctx.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class=\"string\">&#x27;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#x27;</span>);</span><br><span class=\"line\">  ctx.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class=\"string\">&#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ctx.<span class=\"property\">method</span> == <span class=\"string\">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class=\"line\">    ctx.<span class=\"property\">body</span> = <span class=\"number\">200</span>; </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">next</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>方案三 (JSONP)</strong></p>\n<p>事先定义一个用于获取跨域响应数据的回调函数，并通过没有同源策略限制的 <code>script</code>  标签发起一个请求（将回调函数的名称放到这个请求的 <code>query</code>  参数里），然后服务端返回这个回调函数的执行，并将需要响应的数据放到回调函数的参数里，</p>\n<p>优点</p>\n<ul>\n<li>\n<p>它不像 <code>XMLHttpRequest</code>  对象实现的 <code>Ajax</code>  请求那样受到同源策略的限制</p>\n</li>\n<li>\n<p>它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 <code>XMLHttpRequest</code>  或 <code>ActiveX</code>  的支持</p>\n</li>\n<li>\n<p>并且在请求完毕后可以通过调用 <code>callback</code>  的方式回传结果</p>\n<p>用 jsonp 的好处是可以单独让一个 http 请求跨域</p>\n</li>\n</ul>\n<p>缺点：</p>\n<p>​\t它<strong>只支持 <code>GET</code>  请求</strong>而不支持  <code>POST</code>  等其它类型的 HTTP 请求</p>\n</li>\n</ul>\n<h1 id=\"vue的diff算法\"><a class=\"anchor\" href=\"#vue的diff算法\">#</a> vue 的 diff 算法</h1>\n<p><code>diff</code>  算法是一种通过同层的树节点进行比较的高效算法</p>\n<p>其有两个特点：</p>\n<ul>\n<li>\n<p>比较只会在同层级进行，不会跨层级比较</p>\n</li>\n<li>\n<p>在 diff 比较的过程中，循环从两边向中间比较</p>\n<p>当数据发生改变时， <code>set</code>  方法会调用 <code>Dep.notify</code>  通知所有订阅者 <code>Watcher</code> ，订阅者就会调用 <code>patch</code>  给真实的 <code>DOM</code>  打补丁，更新相应的视图</p>\n</li>\n<li>\n<p>当数据发生改变时，订阅者 <code>watcher</code>  就会调用 <code>patch</code>  给真实的 <code>DOM</code>  打补丁</p>\n</li>\n<li>\n<p>通过 <code>isSameVnode</code>  进行判断，相同则调用 <code>patchVnode</code>  方法</p>\n<p>patchVnode 做了以下操作：</p>\n<p>找到对应的真实 <code>dom</code> ，称为 <code>el</code></p>\n<ul>\n<li>如果都有都有文本节点且不相等，将 <code>el</code>  文本节点设置为 <code>Vnode</code>  的文本节点</li>\n<li>如果 <code>oldVnode</code>  有子节点而 <code>VNode</code>  没有，则删除 <code>el</code>  子节点</li>\n<li>如果 <code>oldVnode</code>  没有子节点而 <code>VNode</code>  有，则将 <code>VNode</code>  的子节点真实化后添加到 <code>el</code></li>\n<li>如果两者都有子节点，则执行 <code>updateChildren</code>  函数比较子节点</li>\n</ul>\n<p>updateChildren 主要做了以下操作：</p>\n<ul>\n<li>\n<p>设置新旧 <code>VNode</code>  的头尾指针</p>\n</li>\n<li>\n<p>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用 <code>patchVnode</code>  进行 <code>patch</code>  重复流程、调用 <code>createElem</code>  创建一个新节点，从哈希表寻找  <code>key</code>  一致的 <code>VNode</code>  节点再分情况操作</p>\n<p><code>diff</code>  算法是一种通过同层的树节点进行比较的高效算法</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"vue2和vue3的区别\"><a class=\"anchor\" href=\"#vue2和vue3的区别\">#</a> vue2 和 vue3 的区别</h1>\n<ul>\n<li>响应式原理 api 的改变<br />\n Vue2 响应式原理采用的是 defineProperty，而 vue3 选用的是 proxy。这两者前者是修改对象属性的权限标签，后者是代理整个对象。性能上 proxy 会更加优秀。</li>\n<li>diff 算法，渲染算法的改变<br />\n Vue3 优化 diff 算法。不再像 vue2 那样比对所有 dom，而采用了 block tree 的做法。此外重新渲染的算法里也做了改进，利用了闭包来进行缓存。这使得 vue3 的速度比 vue2 快了 6 倍。</li>\n<li>建立数据 data<br />\n 这里就是 Vue2 与 Vue3 最大的区别 — Vue2 使用 <code>选项类型API（Options API）</code> 对比 Vue3 <code>合成型API（Composition API）</code>  旧的选项型 API 在代码里分割了不同的属性（properties）：data，computed 属性，methods，等等。新的合成型 API 能让我们用方法（function）来分割，相比于旧的 API 使用属性来分组，这样代码会更加简便和整洁。</li>\n<li>**Diff 算法重写：** 新增了最长递归子序列的<a href=\"https://so.csdn.net/so/search?q=%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020\">算法</a>，来计算出最小的修改偏移量。还增加了静态标记</li>\n</ul>\n<h1 id=\"v-show与v-if的区别\"><a class=\"anchor\" href=\"#v-show与v-if的区别\">#</a> v-show 与 v-if 的区别</h1>\n<p>控制手段： <code>v-show</code>  隐藏则是为该元素添加 <code>css--display:none</code> ， <code>dom</code>  元素依旧还在。 <code>v-if</code>  显示隐藏是将 <code>dom</code>  元素整个添加或删除</p>\n<p>编译过程： <code>v-if</code>  切换有一个局部编译 / 卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件； <code>v-show</code>  只是简单的基于 css 切换</p>\n<p>v-show 有 <code>transition</code>  就执行 <code>transition</code> ，没有就直接设置 <code>display</code>  属性</p>\n<p>返回一个 <code>node</code>  节点， <code>render</code>  函数通过表达式的值来决定是否生成 <code>DOM</code></p>\n<h1 id=\"前端性能优化\"><a class=\"anchor\" href=\"#前端性能优化\">#</a> 前端性能优化</h1>\n<ul>\n<li>\n<p><code>减少HTTP请求</code> <br />\n如 Chrome 浏览器最多同时允许对同一个域名 Host 建立 6 个 TCP 连接，不同的浏览器有所区别，减少 http 请求也就是减少我们 html 里 css/js 等资源的数量</p>\n</li>\n<li>\n<p><code>设置浏览器缓存策略</code> 主要为设置缓存策略：</p>\n<ul>\n<li>\n<p>强制缓存：当 web 应用获取资源时，先从 本地 获取，如果有就直接用。强制缓存涉及到的头字段有  <code>Expires</code> （http1.0）和 <code>Cache-Control</code>  (http1.1)，由服务端设置.</p>\n</li>\n<li>\n<p>Expires 接受一个 GMT 格式时间</p>\n</li>\n<li>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token literal-property property\">Expires</span><span class=\"token operator\">:</span> Wed<span class=\"token punctuation\">,</span> <span class=\"token number\">21</span> Oct <span class=\"token number\">2015</span> <span class=\"token number\">07</span><span class=\"token operator\">:</span><span class=\"token number\">28</span><span class=\"token operator\">:</span><span class=\"token number\">00</span> <span class=\"token constant\">GMT</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>code￼<span class=\"token number\">7</span><span class=\"token operator\">--</span><span class=\"token operator\">></span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p><code>createElement</code>  创建  <code>VNode</code>  的过程，每个  <code>VNode</code>  有  <code>children</code> ， <code>children</code>  每个元素也是一个 <code>VNode</code> ，这样就形成了一个虚拟树结构，用于描述真实的 <code>DOM</code>  树结构</p>\n<h1 id=\"组件间通信的方案\"><a class=\"anchor\" href=\"#组件间通信的方案\">#</a> 组件间通信的方案</h1>\n<ol>\n<li>\n<p>通过 props 传递</p>\n<ul>\n<li>适用场景：父组件传递数据给子组件</li>\n<li>子组件设置 <code>props</code>  属性，定义接收父组件传递过来的参数，父组件在使用子组件标签中通过字面量来传递值</li>\n</ul>\n</li>\n<li>\n<p>通过 $emit 触发自定义事件</p>\n<ul>\n<li>适用场景：子组件传递数据给父组件</li>\n<li>子组件通过 <code>$emit触发</code> 自定义事件， <code>$emit</code>  第二个参数为传递的数值，父组件绑定监听器获取到子组件传递过来的参数</li>\n</ul>\n</li>\n<li>\n<p>EventBus</p>\n<ul>\n<li>使用场景：兄弟组件传值</li>\n<li>创建一个中央事件总线 <code>EventBus</code></li>\n<li>兄弟组件通过 <code>$emit</code>  触发自定义事件， <code>$emit</code>  第二个参数为传递的数值，另一个兄弟组件通过 <code>$on</code>  监听自定义事件</li>\n</ul>\n</li>\n<li>\n<p>Provide 与 Inject</p>\n<ol>\n<li>\n<p>在祖先组件定义 <code>provide</code>  属性，返回传递的值</p>\n</li>\n<li>\n<p>在后代组件通过 <code>inject</code>  接收组件传递过来的值</p>\n</li>\n<li>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">provide</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>  </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">&#123;</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token literal-property property\">foo</span><span class=\"token operator\">:</span><span class=\"token string\">'foo'</span>  </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span>  </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span>  </pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token literal-property property\">inject</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 获取到祖先组件传递过来的值</span></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li>\n<p>Vuex</p>\n</li>\n</ol>\n<h1 id=\"vue中key的原理吗\"><a class=\"anchor\" href=\"#vue中key的原理吗\">#</a> vue 中 key 的原理吗</h1>\n<ol>\n<li>当我们在使用 <code>v-for</code>  时，需要给单元加上 <code>key</code></li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in items&quot;</span> <span class=\"attr\">:key</span>=<span class=\"string\">&quot;item.id&quot;</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>用 <code>+new Date()</code>  生成的时间戳作为 <code>key</code> ，手动强制触发重新渲染</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Comp</span> :key=<span class=\"string\">&quot;+new Date()&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在不使用 <code>key</code>  的情况，vue 会原地复用修改 DOM 值增加 DOM 操作</p>\n<p>设置 key 值不一定能提高 diff 效率。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2024/05/27/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/",
            "url": "http://example.com/2024/05/27/%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2/",
            "title": "腾讯一面",
            "date_published": "2024-05-27T01:12:48.000Z",
            "content_html": "<p>1. 有了解过哪些前端框架<br />\n 2.vue 和 react 有什么区别<br />\n 3.vue 可以实现交互吗<br />\n 4. 项目中有哪些状态信息管理（回答 pinia 管理登录信息和 token 令牌）<br />\n5. 单页和多页的区别<br />\n 6. 单页的优点<br />\n 7. 单页的缺点（数据加载多）<br />\n8. 如何解决这个问题（webpack，代码的复用，隐藏一些不可见元素）<br />\n9. 路由的实现，用的什么模式，history 模式<br />\n 10. 场景题<br />\n前端发送 500000 个数据给后端会有什么问题（服务器压力过大，数据访问出错）<br />\n如何解决<br />\n（用 promise 对象发送几个请求）<br />\n了解 promise.all 吗</p>\n",
            "tags": []
        }
    ]
}