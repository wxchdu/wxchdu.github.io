{
    "version": "https://jsonfeed.org/version/1",
    "title": "worked warriors • All posts by \"平时学习\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/06/02/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "url": "http://example.com/2024/06/02/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/",
            "title": "react学习笔记",
            "date_published": "2024-06-02T04:48:10.000Z",
            "content_html": "<h1 id=\"vue和react的区别\"><a class=\"anchor\" href=\"#vue和react的区别\">#</a> vue 和 react 的区别</h1>\n<p>Vue 和 React 存在着很多的共同点：</p>\n<ul>\n<li>数据驱动视图</li>\n<li>组件化</li>\n<li>都使用  <code>Virtual DOM</code></li>\n</ul>\n<p>React 的核心思想是声明式渲染和组件化、单向数据流，React 既不属于 MVC 也不属于 MVVM 架构。</p>\n<p>React 的单向数据流指的是数据主要从父节点通过 props 传递到子节点，如果顶层某个 props 改变了，React 会重新渲染所有的子节点。</p>\n<p>React 的组件写法是 JSX+inline style，也就是吧 HTML 和 CSS 全部写进 JavaScript 中。</p>\n<p>React 主要是通过 setState () 方法来更新状态，状态更新之后，组件也会重新渲染。</p>\n<h1 id=\"reacthooks\"><a class=\"anchor\" href=\"#reacthooks\">#</a> reactHooks</h1>\n<h2 id=\"usestate\"><a class=\"anchor\" href=\"#usestate\">#</a> useState</h2>\n<p>Hook 就是 Javascript 函数，使用它们时有两个额外的规则：</p>\n<ul>\n<li>只能在<strong>函数外层</strong>调用 Hook，不要在循环、条件判断或者子函数中调用</li>\n<li>只能在 <strong>React 的函数组件</strong>和<strong>自定义 Hook</strong> 中调用 Hook。不要在其他 JavaScript 函数中调用</li>\n</ul>\n<p><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">Counter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> setCount(count - 1)&#125;&gt;-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;count&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;(e)</span> =&gt;</span> setCount(e.target.value)&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>等价 class 示例</p>\n<p><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(props);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">count</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> this.setState(&#123; count: this.state.count - 1 &#125;)&#125;&gt;-<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;this.state.count&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;(e)</span> =&gt;</span> this.setState(&#123; count: e.target.value &#125;)&#125; /&gt;</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"useeffect\"><a class=\"anchor\" href=\"#useeffect\">#</a> useEffect</h2>\n<p>在函数组件主体内（React 渲染阶段）改变 DOM</p>\n<p><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">Counter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// useEffect 内的回调函数会在初次渲染后和更新完成后执行</span></span><br><span class=\"line\">  <span class=\"comment\">// 相当于 componentDidMount 和 componentDidUpdate</span></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">title</span> = <span class=\"string\">`You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>count now is &#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>等价 class 示例</p>\n<p><code>useEffect</code>  Hook 函数执行时机类似于 class 组件的  <code>componentDidMount</code> 、 <code>componentDidUpdate</code>  生命周期，不同的是传给  <code>useEffect</code>  的函数会在浏览器完成布局和绘制之后进行异步执行</p>\n<p><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title class_ inherited__\">React.Component</span> &#123;</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">super</span>(props);</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">state</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">count</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">componentDidMount</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">title</span> = <span class=\"string\">`You clicked <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.state.count&#125;</span> times`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">componentDidUpdate</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">title</span> = <span class=\"string\">`You clicked <span class=\"subst\">$&#123;<span class=\"variable language_\">this</span>.state.count&#125;</span> times`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>count now is &#123;this.state.count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>清除 effect</p>\n<p><code>useEffect</code>  Hook 函数可以返回一个清除函数，清除函数会在组件卸载前执行。组件在多次渲染中都会在执行下一个 effect 之前，执行该函数进行清除上一个 effect</p>\n<p>清除函数的执行时机类似于 class 组件 <code>componentDidUnmount</code>  生命周期，这的话使用  <code>useEffect</code>  函数可以将组件中互相关联的部分拆分成更小的函数，防止遗忘导致不必要的内存泄漏</p>\n<p><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">Counter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;start an interval timer&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> timer = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">setCount</span>(<span class=\"function\">(<span class=\"params\">count</span>) =&gt;</span> count + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 返回一个清除函数，在组件卸载前和下一个effect执行前执行</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;destroy effect&#x27;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">clearInterval</span>(timer);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>count now is &#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>默认情况下，effect 会在每一次组件渲染完成后执行。 <code>useEffect</code>  可以接收第二个参数，它是 effect 所依赖的值数组，这样就只有当数组值发生变化才会重新创建订阅。但需要注意的是：</p>\n<p><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">Counter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">document</span>.<span class=\"property\">title</span> = <span class=\"string\">`You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span>;</span><br><span class=\"line\">  &#125;, [count]); <span class=\"comment\">// 仅在 count 更改时更新</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>count now is &#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"usecontent\"><a class=\"anchor\" href=\"#usecontent\">#</a> useContent</h2>\n<p>Context 提供了一个无需为每层组件手动添加 props ，就能在组件树间进行数据传递的方法， <code>useContext</code>  用于函数组件中订阅上层 context 的变更，可以获取上层 context 传递的  <code>value</code>  prop 值</p>\n<p><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useContext, useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> themes = &#123;</span><br><span class=\"line\">  <span class=\"attr\">light</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">foreground</span>: <span class=\"string\">&quot;#000000&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">background</span>: <span class=\"string\">&quot;#eeeeee&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">dark</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">foreground</span>: <span class=\"string\">&quot;#ffffff&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">background</span>: <span class=\"string\">&quot;#222222&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为当前 theme 创建一个 context</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">ThemeContext</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">createContext</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">Toolbar</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [theme, setTheme] = <span class=\"title function_\">useState</span>(themes.<span class=\"property\">dark</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">toggleTheme</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setTheme</span>(<span class=\"function\"><span class=\"params\">currentTheme</span> =&gt;</span> (</span><br><span class=\"line\">      currentTheme === themes.<span class=\"property\">dark</span></span><br><span class=\"line\">        ? themes.<span class=\"property\">light</span></span><br><span class=\"line\">        : themes.<span class=\"property\">dark</span></span><br><span class=\"line\">    ));</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"comment\">// 使用 Provider 将当前 props.value 传递给内部组件</span></span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">ThemeContext.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;theme,</span> <span class=\"attr\">toggleTheme</span>&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">ThemeButton</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">ThemeContext.Provider</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ThemeButton</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 通过 useContext 获取当前 context 值</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; theme, toggleTheme &#125; = <span class=\"title function_\">useContext</span>(<span class=\"title class_\">ThemeContext</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;background:</span> <span class=\"attr\">theme.background</span>, <span class=\"attr\">color:</span> <span class=\"attr\">theme.foreground</span> &#125;&#125; <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;toggleTheme&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      Change the button&#x27;s theme</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"usememo\"><a class=\"anchor\" href=\"#usememo\">#</a> useMemo</h2>\n<ul>\n<li>把 “创建” 函数和依赖项数组作为参数传入  <code>useMemo</code> ，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算</li>\n<li>传入  <code>useMemo</code>  的函数会在渲染期间执行，不要在这个函数内部执行与渲染无关的操作</li>\n<li>如果没有提供依赖项数组， <code>useMemo</code>  在每次渲染时都会计算新的值</li>\n</ul>\n<p><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useState, useMemo &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">counterText</span>(<span class=\"params\">&#123; countInfo &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;countInfo.name&#125;</span> updated`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;countInfo.name&#125;: &#123;countInfo.number&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// // 使用 React.memo 检查 props 变更，复用最近一次渲染结果</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">CounterText</span> = <span class=\"title class_\">React</span>.<span class=\"title function_\">memo</span>(counterText);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">Counter</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count1, setCount1] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count2, setCount2] = <span class=\"title function_\">useState</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> countInfo1 = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;count1&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">number</span>: count1</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"comment\">// 使用 useMemo 缓存最近一次计算结果，会在依赖项改变时才重新计算</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> countInfo2 = <span class=\"title function_\">useMemo</span>(<span class=\"function\">() =&gt;</span> (&#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;count2&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">number</span>: count2</span><br><span class=\"line\">  &#125;), [count2]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">CounterText</span> <span class=\"attr\">countInfo</span>=<span class=\"string\">&#123;countInfo1&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> setCount1(count1 + 1)&#125;&gt;Add count1<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">CounterText</span> <span class=\"attr\">countInfo</span>=<span class=\"string\">&#123;countInfo2&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> setCount2(count2 + 1)&#125;&gt;Add count2<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"useref\"><a class=\"anchor\" href=\"#useref\">#</a> useRef</h2>\n<p><code>useRef</code>  用于返回一个可变的 ref 对象，其  <code>.current</code>  属性被初始化为传入的参数（ <code>initialValue</code> ）</p>\n<p><code>useRef</code>  创建的 ref 对象就是一个普通的 JavaScript 对象，而  <code>useRef()</code>  和自建一个  <code>&#123;current: ...&#125;</code>  对象的唯一区别是， <code>useRef</code>  会在每次渲染时返回同一个 ref 对象</p>\n<p>使用  <code>useRef</code>  创建的 ref 对象可以作为访问 DOM 的方式，将 ref 对象以  <code>&lt;div ref=&#123;myRef&#125; /&gt;</code>  形式传入组件，React 会在组件创建完成后会将 ref 对象的  <code>.current</code>  属性设置为相应的 DOM 节点</p>\n<p><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"title class_\">React</span>, &#123; useRef &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">function</span> <span class=\"title function_\">FocusButton</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> inputEl = <span class=\"title function_\">useRef</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">onButtonClick</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">    inputEl.<span class=\"property\">current</span>.<span class=\"title function_\">focus</span>();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;inputEl&#125;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;onButtonClick&#125;</span>&gt;</span>Focus the input<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>有状态组件： 是一个 class 类，继承 componet （用于需要一些状态去存储和修改数据）</p>\n<p>无状态组件： 是一个 es6 写的箭头函数函数，并不继承 componet（用于一些简单的逻辑，比如，父组件向子组件传属性值）</p>\n<p>（1） 最大的区别是无状态组件，无法使用 state，因为 state 是继承 componet</p>\n<p>（2）无状态组件，没有生命周期函数，生命周期函数是基于 state 的</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2024/06/02/nodejs%E7%B3%BB%E5%88%97/",
            "url": "http://example.com/2024/06/02/nodejs%E7%B3%BB%E5%88%97/",
            "title": "nodejs系列",
            "date_published": "2024-06-02T04:47:14.000Z",
            "content_html": "<h1 id=\"node-js-有哪些全局对象\"><a class=\"anchor\" href=\"#node-js-有哪些全局对象\">#</a> Node. js 有哪些全局对象</h1>\n<p>下面给出一些常见的全局对象：</p>\n<ul>\n<li>Class:Buffer</li>\n<li>process</li>\n<li>console</li>\n<li>clearInterval、setInterval</li>\n<li>clearTimeout、setTimeout</li>\n<li>global</li>\n</ul>\n<h2 id=\"classbuffer\"><a class=\"anchor\" href=\"#classbuffer\">#</a> Class:Buffer</h2>\n<p>可以处理二进制以及非 <code>Unicode</code>  编码的数据</p>\n<p>在 <code>Buffer</code>  类实例化中存储了原始数据。 <code>Buffer</code>  类似于一个整数数组，在 V8 堆原始存储空间给它分配了内存</p>\n<p>一旦创建了 <code>Buffer</code>  实例，则无法改变大小</p>\n<h2 id=\"process\"><a class=\"anchor\" href=\"#process\">#</a> process</h2>\n<p>进程对象，提供有关当前进程的信息和控制</p>\n<p>包括在执行 <code>node</code>  程序进程时，如果需要传递参数，我们想要获取这个参数需要在 <code>process</code>  内置对象中</p>\n<p>启动进程：</p>\n<p><figure class=\"highlight text\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node index.js 参数1 参数2 参数3</span><br></pre></td></tr></table></figure></p>\n<p>index.js 文件如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process.<span class=\"property\">argv</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">val, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`<span class=\"subst\">$&#123;index&#125;</span>: <span class=\"subst\">$&#123;val&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>输出如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/local/bin/node</span><br><span class=\"line\">/<span class=\"title class_\">Users</span>/mjr/work/node/process-args.<span class=\"property\">js</span></span><br><span class=\"line\">参数<span class=\"number\">1</span></span><br><span class=\"line\">参数<span class=\"number\">2</span></span><br><span class=\"line\">参数<span class=\"number\">3</span></span><br></pre></td></tr></table></figure></p>\n<p>除此之外，还包括一些其他信息如版本、操作系统等</p>\n<h2 id=\"console\"><a class=\"anchor\" href=\"#console\">#</a> console</h2>\n<p>用来打印 <code>stdout</code>  和 <code>stderr</code></p>\n<p>最常用的输入内容的方式：console.log</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<p>清空控制台：console.clear</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"property\">clear</span></span><br></pre></td></tr></table></figure></p>\n<p>打印函数的调用栈：console.trace</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">demo</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">demo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"title function_\">foo</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">trace</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"setintervalclearinterval-setinterval\"><a class=\"anchor\" href=\"#setintervalclearinterval-setinterval\">#</a> （setinterval)clearInterval、setInterval</h2>\n<p>设置定时器与清除定时器</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setInterval</span>(callback, delay[, ...args])</span><br></pre></td></tr></table></figure></p>\n<p><code>callback</code>  每 <code>delay</code>  毫秒重复执行一次</p>\n<p><code>clearInterval</code>  则为对应发取消定时器的方法</p>\n<h2 id=\"cleartimeout-settimeout\"><a class=\"anchor\" href=\"#cleartimeout-settimeout\">#</a> clearTimeout、setTimeout</h2>\n<p>设置延时器与清除延时器</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(callback,delay[,...args])</span><br></pre></td></tr></table></figure></p>\n<p><code>callback</code>  在 <code>delay</code>  毫秒后执行一次</p>\n<p><code>clearTimeout</code>  则为对应取消延时器的方法</p>\n<h2 id=\"global\"><a class=\"anchor\" href=\"#global\">#</a> global</h2>\n<p>全局命名空间对象，讲到的 <code>process</code> 、 <code>console</code> 、 <code>setTimeout</code>  等都有放到 <code>global</code>  中</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(process === <span class=\"variable language_\">global</span>.<span class=\"property\">process</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"node-中的-process-的理解有哪些常用方法\"><a class=\"anchor\" href=\"#node-中的-process-的理解有哪些常用方法\">#</a> Node 中的 process 的理解，有哪些常用方法？</h1>\n<p><code>process</code>  对象是一个全局变量，提供了有关当前  <code>Node.js</code>  进程的信息并对其进行控制，作为一个全局变量</p>\n<p>我们都知道，进程计算机系统进行资源分配和调度的基本单位，是操作系统结构的基础，是线程的容器</p>\n<p>当我们启动一个 <code>js</code>  文件，实际就是开启了一个服务进程，每个进程都拥有自己的独立空间地址、数据栈，像另一个进程无法访问当前进程的变量、数据结构，只有数据通信后，进程之间才可以数据共享</p>\n<p>由于 <code>JavaScript</code>  是一个单线程语言，所以通过 <code>node xxx</code>  启动一个文件后，只有一条主线程</p>\n<p>关于 <code>process</code>  常见的属性有如下：</p>\n<ul>\n<li>process.env：环境变量，例如通过 `process.env.NODE_ENV 获取不同环境项目配置信息</li>\n<li>process.nextTick：这个在谈及  <code>EventLoop</code>  时经常为会提到</li>\n<li>process.pid：获取当前进程 id</li>\n<li>process.ppid：当前进程对应的父进程</li>\n<li>process.cwd ()：获取当前进程工作目录，</li>\n<li>process.platform：获取当前进程运行的操作系统平台</li>\n<li>process.uptime ()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</li>\n<li>进程事件： process.on (‘uncaughtException’,cb) 捕获异常信息、 process.on (‘exit’,cb）进程推出监听</li>\n<li>三个标准流： process.stdout 标准输出、 process.stdin 标准输入、 process.stderr 标准错误输出</li>\n<li>process.title 指定进程名称，有的时候需要给进程指定一个名称</li>\n</ul>\n<h1 id=\"node-中的-fs模块有哪些常用方法\"><a class=\"anchor\" href=\"#node-中的-fs模块有哪些常用方法\">#</a> Node 中的 fs 模块，有哪些常用方法</h1>\n<p>可以说，所有与文件的操作都是通过 <code>fs</code>  核心模块实现</p>\n<p>导入模块如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这个模块对所有文件系统操作提供异步（不具有 <code>sync</code>  后缀）和同步（具有  <code>sync</code>  后缀）两种操作方式，而供开发者选择</p>\n<h2 id=\"fsreadfilesync\"><a class=\"anchor\" href=\"#fsreadfilesync\">#</a> fs.readFileSync</h2>\n<p>同步读取，参数如下：</p>\n<ul>\n<li>第一个参数为读取文件的路径或文件描述符</li>\n<li>第二个参数为 options，默认值为 null，其中有 encoding（编码，默认为 null）和 flag（标识位，默认为 r），也可直接传入 encoding</li>\n</ul>\n<p>结果为返回文件的内容</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> buf = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;1.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> data = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;1.txt&quot;</span>, <span class=\"string\">&quot;utf8&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(buf); <span class=\"comment\">// &lt;Buffer 48 65 6c 6c 6f&gt;</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data); <span class=\"comment\">// Hello</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"fsreadfile\"><a class=\"anchor\" href=\"#fsreadfile\">#</a> fs.readFile</h2>\n<p>异步读取方法  <code>readFile</code>  与  <code>readFileSync</code>  的前两个参数相同，最后一个参数为回调函数，函数内有两个参数  <code>err</code> （错误）和  <code>data</code> （数据），该方法没有返回值，回调函数在读取文件成功后执行</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">readFile</span>(<span class=\"string\">&quot;1.txt&quot;</span>, <span class=\"string\">&quot;utf8&quot;</span>, <span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(!err)&#123;</span><br><span class=\"line\">       <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data); <span class=\"comment\">// Hello</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"writefilesync\"><a class=\"anchor\" href=\"#writefilesync\">#</a> writeFileSync</h2>\n<p>同步写入，有三个参数：</p>\n<ul>\n<li>第一个参数为写入文件的路径或文件描述符</li>\n<li>第二个参数为写入的数据，类型为 String 或 Buffer</li>\n<li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 w）和 mode（权限位，默认为 0o666），也可直接传入 encoding</li>\n</ul>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">writeFileSync</span>(<span class=\"string\">&quot;2.txt&quot;</span>, <span class=\"string\">&quot;Hello world&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> data = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;2.txt&quot;</span>, <span class=\"string\">&quot;utf8&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data); <span class=\"comment\">// Hello world</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"writefile\"><a class=\"anchor\" href=\"#writefile\">#</a> writeFile</h2>\n<p>异步写入， <code>writeFile</code>  与  <code>writeFileSync</code>  的前三个参数相同，最后一个参数为回调函数，函数内有一个参数  <code>err</code> （错误），回调函数在文件写入数据成功后执行</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">writeFile</span>(<span class=\"string\">&quot;2.txt&quot;</span>, <span class=\"string\">&quot;Hello world&quot;</span>, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">        fs.<span class=\"title function_\">readFile</span>(<span class=\"string\">&quot;2.txt&quot;</span>, <span class=\"string\">&quot;utf8&quot;</span>, <span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data); <span class=\"comment\">// Hello world</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"appendfilesync\"><a class=\"anchor\" href=\"#appendfilesync\">#</a> appendFileSync</h2>\n<p>参数如下：</p>\n<ul>\n<li>第一个参数为写入文件的路径或文件描述符</li>\n<li>第二个参数为写入的数据，类型为 String 或 Buffer</li>\n<li>第三个参数为 options，默认值为 null，其中有 encoding（编码，默认为 utf8）、 flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可直接传入 encoding</li>\n</ul>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">appendFileSync</span>(<span class=\"string\">&quot;3.txt&quot;</span>, <span class=\"string\">&quot; world&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> data = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;3.txt&quot;</span>, <span class=\"string\">&quot;utf8&quot;</span>);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"appendfile\"><a class=\"anchor\" href=\"#appendfile\">#</a> appendFile</h2>\n<p>异步追加写入方法  <code>appendFile</code>  与  <code>appendFileSync</code>  的前三个参数相同，最后一个参数为回调函数，函数内有一个参数  <code>err</code> （错误），回调函数在文件追加写入数据成功后执行</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">appendFile</span>(<span class=\"string\">&quot;3.txt&quot;</span>, <span class=\"string\">&quot; world&quot;</span>, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err) &#123;</span><br><span class=\"line\">        fs.<span class=\"title function_\">readFile</span>(<span class=\"string\">&quot;3.txt&quot;</span>, <span class=\"string\">&quot;utf8&quot;</span>, <span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data); <span class=\"comment\">// Hello world</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"copyfilesync\"><a class=\"anchor\" href=\"#copyfilesync\">#</a> copyFileSync</h2>\n<p>同步拷贝</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">copyFileSync</span>(<span class=\"string\">&quot;3.txt&quot;</span>, <span class=\"string\">&quot;4.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> data = fs.<span class=\"title function_\">readFileSync</span>(<span class=\"string\">&quot;4.txt&quot;</span>, <span class=\"string\">&quot;utf8&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data); <span class=\"comment\">// Hello world</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"copyfile\"><a class=\"anchor\" href=\"#copyfile\">#</a> copyFile</h2>\n<p>异步拷贝</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fs.<span class=\"title function_\">copyFile</span>(<span class=\"string\">&quot;3.txt&quot;</span>, <span class=\"string\">&quot;4.txt&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    fs.<span class=\"title function_\">readFile</span>(<span class=\"string\">&quot;4.txt&quot;</span>, <span class=\"string\">&quot;utf8&quot;</span>, <span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data); <span class=\"comment\">// Hello world</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"mkdirsync\"><a class=\"anchor\" href=\"#mkdirsync\">#</a> mkdirSync</h2>\n<p>同步创建，参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件目录都存在，否则会抛出异常</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设已经有了 a 文件夹和 a 下的 b 文件夹</span></span><br><span class=\"line\">fs.<span class=\"title function_\">mkdirSync</span>(<span class=\"string\">&quot;a/b/c&quot;</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"mkdir\"><a class=\"anchor\" href=\"#mkdir\">#</a> mkdir</h2>\n<p>异步创建，第二个参数为回调函数</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.<span class=\"title function_\">mkdir</span>(<span class=\"string\">&quot;a/b/c&quot;</span>, <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!err) <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;创建成功&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2024/06/02/js%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/",
            "url": "http://example.com/2024/06/02/js%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/",
            "title": "js相关问题",
            "date_published": "2024-06-02T04:45:26.000Z",
            "content_html": "<h1 id=\"js数据类型\"><a class=\"anchor\" href=\"#js数据类型\">#</a> js 数据类型</h1>\n<p>值类型 (基本类型)：字符串（String）、数字 (Number)、布尔 (Boolean)、空（Null）、未定义（Undefined）、Symbol。<br />\n引用数据类型（对象类型）：对象 (Object)、数组 (Array)、函数 (Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）。<br />\nSymbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值 (标识符)。</p>\n<h1 id=\"js数组的一些方法\"><a class=\"anchor\" href=\"#js数组的一些方法\">#</a> js 数组的一些方法</h1>\n<p>1.push();<br />\n 功能：在数组最后一位添加一个或多个元素，并返回新数组的长度，改变原数组.(添加多个元素用逗号隔开)</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">   <span class=\"keyword\">var</span> rel = arr.<span class=\"title function_\">push</span>(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>);</span><br><span class=\"line\">   <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [1, 2, &quot;c&quot;, &quot;A&quot;, &quot;B&quot;]</span></span><br><span class=\"line\">   <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rel); <span class=\"comment\">//  5  (数组长度)</span></span><br></pre></td></tr></table></figure></p>\n<p>2.unshift();<br />\n 功能：在数组第一位添加一个或多个元素，并返回新数组的长度，改变原数组。(添加多个元素用逗号隔开)</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\">   <span class=\"keyword\">var</span> rel = arr.<span class=\"title function_\">unshift</span>(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>);</span><br><span class=\"line\">   <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [ &quot;A&quot;, &quot;B&quot;,1, 2, &quot;c&quot;]</span></span><br><span class=\"line\">   <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rel); <span class=\"comment\">//  5  (数组长度)</span></span><br></pre></td></tr></table></figure></p>\n<p>3.pop();<br />\n 功能：删除数组的最后一位，并且返回删除的数据，会改变原来的数组。(该方法不接受参数，且每次只能删除最后一个)</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\"> <span class=\"keyword\">var</span> rel = arr.<span class=\"title function_\">pop</span>();</span><br><span class=\"line\"> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(arr); <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(rel); <span class=\"comment\">// c</span></span><br></pre></td></tr></table></figure></p>\n<p>4.shift();<br />\n 功能：删除数组的第一位数据，并且返回被删除的数据，会改变原来的数组。(该方法同 pop ()；一样不接受参数，且每次只能删除数组第一个)</p>\n<pre><code>var arr = [&quot;a&quot;,&quot;b&quot;, &quot;c&quot;];\nvar rel = arr.shift();\nconsole.log(arr); // ['b', &quot;c&quot;]\nconsole.log(rel); // a\n</code></pre>\n<h1 id=\"promise\"><a class=\"anchor\" href=\"#promise\">#</a> Promise</h1>\n<p>Promise 创建</p>\n<p>new Promise (function (resolve, reject) { // 要做的事情... });</p>\n<p>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；<br />\nresolve 和 reject 并不能够使起始函数停止运行，别忘了 return。<br />\nPromise 对象有以下两个特点:</p>\n<p>1、对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：</p>\n<p>pending: 初始状态，不是成功或失败状态。<br />\nfulfilled: 意味着操作成功完成。<br />\nrejected: 意味着操作失败。<br />\n2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。</p>\n<p>Promise 构造函数返回一个 Promise 对象，该对象具有以下几个方法：</p>\n<p>then：用于处理 Promise 成功状态的回调函数。<br />\ncatch：用于处理 Promise 失败状态的回调函数。<br />\nfinally：无论 Promise 是成功还是失败，都会执行的回调函数。</p>\n<h1 id=\"es6新特性\"><a class=\"anchor\" href=\"#es6新特性\">#</a> ES6 新特性：</h1>\n<h2 id=\"箭头函数参数-执行的操作\"><a class=\"anchor\" href=\"#箭头函数参数-执行的操作\">#</a> 箭头函数： <code>(参数) =&gt; &#123; 执行的操作 &#125;</code></h2>\n<p>与普通函数的区别：</p>\n<p>箭头函数没有 this，所以需要通过查找作用域链来确定 this 的值，这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this，</p>\n<p>箭头函数没有自己的 arguments 对象，但是可以访问外围函数的 arguments 对象</p>\n<p>不能通过 new 关键字调用，同样也没有 new.target 值和原型</p>\n<h2 id=\"let与const关键字\"><a class=\"anchor\" href=\"#let与const关键字\">#</a> let 与 const 关键字：</h2>\n<p>let 声明的变量只在 let 命令所在的代码块内有效。</p>\n<p>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</p>\n<p>let 与 var 区别：</p>\n<p>var 在全局范围内有效：全局作用<br />\n var 可以声明多次：var a = 1, var a =2<br />\nvar 会提升变量： console.log (b); var b = &quot;后声明&quot;</p>\n<h2 id=\"解构赋值\"><a class=\"anchor\" href=\"#解构赋值\">#</a> 解构赋值</h2>\n<ul>\n<li>是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</li>\n<li>解构模型：\n<ol>\n<li>解构的源，解构赋值表达式的右边部分。</li>\n<li>解构的目标，解构赋值表达式的左边部分。</li>\n</ol>\n</li>\n</ul>\n<p>举例：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [a, b, c] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]; <span class=\"comment\">// a = 1 // b = 2 // c = 3</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"null-和-undefined-的区别\"><a class=\"anchor\" href=\"#null-和-undefined-的区别\">#</a> null 和 undefined 的区别？</h1>\n<p>undefined 表示一个变量没有被声明，或者被声明了但没有被赋值（未初始化），一个没有传入实参的形参变量的值为 undefined，如果一个函数什么都不返回，则该函数默认返回 undefined。</p>\n<blockquote>\n<p>（1） 作为函数的参数，表示该函数的参数不是对象。</p>\n<p>（2） 作为对象原型链的终点。</p>\n</blockquote>\n<blockquote>\n<p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i;</span><br><span class=\"line\">i <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\">x</span>)&#123;<span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x)&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>() <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span>  o = <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">o.<span class=\"property\">p</span> <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"title function_\">f</span>();</span><br><span class=\"line\">x <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>null 则表示 &quot;什么都没有&quot;，即 &quot;空值&quot;。Javascript 将未赋值的变量默认值设为 undefined ；Javascript 从来不会将变量设为 null 。. 它是用来让程序员表明某个用 var 声明的变量时没有值的；</p>\n<p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(<span class=\"title class_\">Object</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>)</span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"防抖和节流\"><a class=\"anchor\" href=\"#防抖和节流\">#</a> 防抖和节流</h1>\n<p><strong>防抖与节流？</strong></p>\n<ol>\n<li>\n<p>防抖：<strong>指触发事件后在 n 秒内函数只能执行一次</strong>，如果在 n 秒内又触发了事件，则会<strong>重新计算函数执行时间</strong>。</p>\n<p>实现： <code>setTimeout</code></p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">debounce</span>(<span class=\"params\">func, wait</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timeout;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> context = <span class=\"variable language_\">this</span>; <span class=\"comment\">// 保存this指向</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> args = <span class=\"variable language_\">arguments</span>; <span class=\"comment\">// 拿到event对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timeout)</span><br><span class=\"line\">        timeout = <span class=\"built_in\">setTimeout</span>(<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">            func.<span class=\"title function_\">apply</span>(context, args)</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>节流：<strong>是指连续触发事件但是在 n 秒中只执行一次函数</strong></p>\n<p>实现： <code>时间戳 / 定时器</code></p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">throttled2</span>(<span class=\"params\">fn, delay = <span class=\"number\">500</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> timer = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\">...args</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">            timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                fn.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>, args)</span><br><span class=\"line\">                timer = <span class=\"literal\">null</span></span><br><span class=\"line\">            &#125;, delay);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ol>\n<h1 id=\"深拷贝与浅拷贝\"><a class=\"anchor\" href=\"#深拷贝与浅拷贝\">#</a> 深拷贝与浅拷贝</h1>\n<p>深拷贝：</p>\n<p>创建一个新的对象和数组，将原对象的各项属性的 “值”（数组的所有元素）拷贝过来，是 “值” 而不是 “引用”<br />\n 深拷贝就是把一个对象，从内存中完整的拷贝出来，从堆内存中开辟了新区域，用来存新对象，并且修改新对象不会影响原对象<br />\n浅拷贝：</p>\n<p>将原对象或原数组的引用直接赋给新对象，新数组，新对象只是对原对象的一个引用，而不复制对象本身，新旧对象还是共享同一块内存<br />\n如果属性是一个基本数据类型，拷贝就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址</p>\n<h2 id=\"实现深拷贝\"><a class=\"anchor\" href=\"#实现深拷贝\">#</a> 实现深拷贝</h2>\n<p>使用递归的方式实现深拷贝</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">deepClone</span>(<span class=\"params\">obj</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objClone = <span class=\"title class_\">Array</span>.<span class=\"title function_\">isArray</span>(obj)?[]:&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(obj &amp;&amp; <span class=\"keyword\">typeof</span> obj===<span class=\"string\">&quot;object&quot;</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obj.<span class=\"title function_\">hasOwnProperty</span>(key))&#123;</span><br><span class=\"line\">                <span class=\"comment\">//判断obj子元素是否为对象，如果是，递归复制</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(obj[key]&amp;&amp;<span class=\"keyword\">typeof</span> obj[key] ===<span class=\"string\">&quot;object&quot;</span>)&#123;</span><br><span class=\"line\">                    objClone[key] = <span class=\"title function_\">deepClone</span>(obj[key]);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//如果不是，简单复制</span></span><br><span class=\"line\">                    objClone[key] = obj[key];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objClone;</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"><span class=\"keyword\">let</span> a=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">    b=<span class=\"title function_\">deepClone</span>(a);</span><br><span class=\"line\">a[<span class=\"number\">0</span>]=<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a,b);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>Json.stringify 和 Json.parse：</p>\n<p>用 Json.stringify 把对象转换成字符串，再用 Json.parse 把字符串转换成新的对象。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">d</span>: [<span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> jsontext = <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(obj)</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 =<span class=\"title class_\">JSON</span>.<span class=\"title function_\">parse</span>(jsontext) </span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj1);</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"property\">a</span>.<span class=\"property\">d</span>[<span class=\"number\">0</span>] = <span class=\"number\">666</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj1);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>可以转成 Json 格式的对象才能使用这种方法，如果对象中包含 function 或 RegExp 这些就不能用这种方法了。</p>\n<p>函数库 lodash 的_.cloneDeep 方法</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _ = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;lodash&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">a</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">c</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"attr\">d</span>: [<span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">b</span>: <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = _.<span class=\"title function_\">cloneDeep</span>(obj)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj === obj1);<span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"js-的几种模块规范\"><a class=\"anchor\" href=\"#js-的几种模块规范\">#</a> js 的几种模块规范</h1>\n<p>​\t<strong>第一种是 CommonJS 方案</strong>，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</p>\n<p>​\t<strong>第二种是 AMD 方案</strong>，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</p>\n<p>​\t<strong>第三种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</strong></p>\n<p>import 是 ES6 中的语法标准也是用来加载模块文件的，import 函数可以读取并执行一个 JavaScript 文件，然后返回该模块的 export 命令指定输出的代码。export 与 export default 均可用于导出常量、函数、文件、模块，export 可以有多个，export default 只能有一个。</p>\n<p>require 定义模块：module 变量代表当前模块，它的 exports 属性是对外的接口。通过 exports 可以将模块从模块中导出，其他文件加载该模块实际上就是读取 module.exports 变量，他们可以是变量、函数、对象等。在 node 中如果用 exports 进行导出的话系统会系统帮您转成 module.exports 的，只是导出需要定义导出名。</p>\n<p>require 与 import 的区别</p>\n<p>1，require 是 CommonJS 规范的模块化语法，import 是 ECMAScript 6 规范的模块化语法；</p>\n<p>2，require 是运行时加载，import 是编译时加载；</p>\n<p>3，require 可以写在代码的任意位置，import 只能写在文件的最顶端且不可在条件语句或函数作用域中使用；</p>\n<h1 id=\"浏览器渲染页面的原理及流程\"><a class=\"anchor\" href=\"#浏览器渲染页面的原理及流程\">#</a> 浏览器渲染页面的原理及流程</h1>\n<p>浏览器将域名通过网络通信从服务器拿到 html 文件后，如何渲染页面呢？</p>\n<p>1. 根据 html 文件构建 DOM 树和 CSSOM 树。构建 DOM 树期间，如果遇到 JS，阻塞 DOM 树及 CSSOM 树的构建，优先加载 JS 文件，加载完毕，再继续构建 DOM 树及 CSSOM 树。+<br />\n2. 构建渲染树（Render Tree）。<br />\n3. 页面的重绘（repaint）与重排（reflow，也有称回流）。页面渲染完成后，若 JS 操作了 DOM 节点，根据 JS 对 DOM 操作动作的大小，浏览器对页面进行重绘或是回流</p>\n<h1 id=\"js闭包\"><a class=\"anchor\" href=\"#js闭包\">#</a> js 闭包</h1>\n<p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 &quot;定义在一个函数内部的函数&quot;。</p>\n<p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>\n<p>它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　<span class=\"keyword\">function</span> <span class=\"title function_\">f1</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　<span class=\"keyword\">var</span> n=<span class=\"number\">999</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　nAdd=<span class=\"keyword\">function</span>(<span class=\"params\"></span>)&#123;n+=<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　<span class=\"keyword\">function</span> <span class=\"title function_\">f2</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">　　　　　　<span class=\"title function_\">alert</span>(n);</span><br><span class=\"line\">　　　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　<span class=\"keyword\">return</span> f2;</span><br><span class=\"line\"></span><br><span class=\"line\">　　&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">　　<span class=\"keyword\">var</span> result=<span class=\"title function_\">f1</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">　　<span class=\"title function_\">result</span>(); <span class=\"comment\">// 999</span></span><br><span class=\"line\"></span><br><span class=\"line\">　　<span class=\"title function_\">nAdd</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">　　<span class=\"title function_\">result</span>(); <span class=\"comment\">// 1000</span></span><br></pre></td></tr></table></figure></p>\n<p>在这段代码中，result 实际上就是闭包 f2 函数。它一共运行了两次，第一次的值是 999，第二次的值是 1000。这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2024/05/29/TS%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/",
            "url": "http://example.com/2024/05/29/TS%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B/",
            "title": "TS学习记录",
            "date_published": "2024-05-29T01:12:48.000Z",
            "content_html": "<h1 id=\"typescript的内置数据类型有哪些\"><a class=\"anchor\" href=\"#typescript的内置数据类型有哪些\">#</a> TypeScript 的内置数据类型有哪些？</h1>\n<p>在 Typescript 中，内置的数据类型也称为原始数据类型。</p>\n<p>boolean（布尔类型）</p>\n<p>number（数字类型）</p>\n<p>string（字符串类型）</p>\n<p>void 类型</p>\n<p>null 和 undefined 类型</p>\n<p>array（数组类型）</p>\n<p>tuple（元组类型）：允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</p>\n<p>enum（枚举类型）： <code>enum</code>  类型是对 JavaScript 标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字</p>\n<p>any（任意类型）</p>\n<p>never 类型</p>\n<p>object 对象类型</p>\n<p>unknown 是一个类型安全的 any，不能直接赋值给其他类型的变量，如果要赋值需要先做判断，或者使用断言</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">a</span>:<span class=\"built_in\">unknown</span>;</span><br><span class=\"line\">a=<span class=\"string\">&quot;123&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">b = a <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>;</span><br></pre></td></tr></table></figure></p>\n<p>void 表示返回空，可以返回 null 或 undefined，never 表示没有返回值，null 和 undefined 也不能返回</p>\n<p>object 表示对象类型但经常是指定对象类型的如</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a : &#123;<span class=\"attr\">name</span>:<span class=\"built_in\">string</span>&#125;;</span><br><span class=\"line\">a=&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;xunwukong&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果想定义多个属性名可以：</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">b</span>:&#123;<span class=\"attr\">name</span>:<span class=\"built_in\">string</span>,[<span class=\"attr\">prop</span>:<span class=\"built_in\">string</span>]:<span class=\"built_in\">string</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">b=&#123;<span class=\"attr\">name</span>:<span class=\"string\">&quot;zhubaje&quot;</span>,<span class=\"attr\">gendle</span>:<span class=\"string\">&quot;nan&quot;</span>,<span class=\"attr\">age</span>:<span class=\"string\">&quot;18&quot;</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>prop:string 表示属性名的类型，：sting 表示属性值的类型。</p>\n<p>同样，还可以定义函数：</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> c : <span class=\"function\">(<span class=\"params\">a:<span class=\"built_in\">number</span>,b:<span class=\"built_in\">number</span></span>)=&gt;</span><span class=\"built_in\">number</span>;</span><br><span class=\"line\">c = <span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可以定义数组：</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> d : <span class=\"built_in\">string</span>[];</span><br></pre></td></tr></table></figure></p>\n<p>tuple 表示固定类型和长度的数组，类型和长度不能变</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> e : [<span class=\"built_in\">string</span>,<span class=\"built_in\">number</span>];</span><br><span class=\"line\">e = [<span class=\"string\">&quot;hello&quot;</span>,<span class=\"number\">123</span>];</span><br></pre></td></tr></table></figure></p>\n<p>enum 表示枚举类型，用于赋予友好的名字</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Gneder</span>&#123;</span><br><span class=\"line\">  male=<span class=\"number\">0</span>,</span><br><span class=\"line\">  female=<span class=\"number\">1</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> f : &#123;<span class=\"attr\">name</span>: <span class=\"built_in\">string</span>,<span class=\"attr\">gender</span>:<span class=\"title class_\">Gneder</span>&#125;;</span><br><span class=\"line\">f = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&quot;xunwukong&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">gender</span>: <span class=\"title class_\">Gneder</span>.<span class=\"property\">male</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>类型可以起别名用于简化</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> myType = <span class=\"number\">1</span>|<span class=\"number\">2</span>|<span class=\"number\">3</span>|<span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">g</span>:myType;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"ts的配置文件\"><a class=\"anchor\" href=\"#ts的配置文件\">#</a> ts 的配置文件</h1>\n<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>如果一个目录下存在一个 <code>tsconfig.json</code>  文件，那么它意味着这个目录是 TypeScript 项目的根目录。  <code>tsconfig.json</code>  文件中指定了用来编译这个项目的根文件和编译选项。 一个项目可以通过以下方式之一来编译：</p>\n<ul>\n<li>\n<p>使用 <code>&quot;include&quot;</code>  和 <code>&quot;exclude&quot;</code>  属性</p>\n<p><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;outDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./built&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;allowJs&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;es5&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;include&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;./src/**/*&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<p>include 用来包含那些文件 ** 表示任意目录，* 表示任意文件</p>\n<p>compilerOptions 表示编译选项</p>\n<p>有很多</p>\n<p><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">&quot;incremental&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度</span></span><br><span class=\"line\"><span class=\"attr\">&quot;tsBuildInfoFile&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./buildFile&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 增量编译文件的存储位置</span></span><br><span class=\"line\"><span class=\"attr\">&quot;diagnostics&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 打印诊断信息 </span></span><br><span class=\"line\"><span class=\"attr\">&quot;target&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;ES5&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 目标语言的版本</span></span><br><span class=\"line\"><span class=\"attr\">&quot;module&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;CommonJS&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 生成代码的模板标准</span></span><br><span class=\"line\">                 <span class=\"comment\">// 默认值 target === &quot;es3&quot; or &quot;es5&quot; ?&quot;commonjs&quot; : &quot;es6&quot;</span></span><br><span class=\"line\"><span class=\"attr\">&quot;outFile&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./app.js&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，</span></span><br><span class=\"line\">                      <span class=\"comment\">// 即开启时应设置&quot;module&quot;: &quot;AMD&quot;,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;lib&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 编译时引入的 ES 功能库，包括：es5 、es6、es7、dom 等。// 如果未设置，则默认为： target 为 es5 时: [&quot;dom&quot;, &quot;es5&quot;, &quot;scripthost&quot;] </span></span><br><span class=\"line\"><span class=\"comment\">//target 为 es6 时: [&quot;dom&quot;, &quot;es6&quot;, &quot;dom.iterable&quot;, &quot;scripthost&quot;]</span></span><br><span class=\"line\"><span class=\"attr\">&quot;allowJS&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 允许编译器编译JS，JSX文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;checkJs&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 允许在JS文件中报错，通常与allowJS一起使用</span></span><br><span class=\"line\"><span class=\"attr\">&quot;outDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./dist&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 指定输出目录</span></span><br><span class=\"line\"><span class=\"attr\">&quot;rootDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 指定输出文件目录(用于输出)，用于控制输出目录结构</span></span><br><span class=\"line\"><span class=\"attr\">&quot;declaration&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 生成声明文件，开启后会自动生成声明文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;declarationDir&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./file&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 指定生成声明文件存放目录</span></span><br><span class=\"line\"><span class=\"attr\">&quot;emitDeclarationOnly&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 只生成声明文件，而不会生成js文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;sourceMap&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 生成目标文件的sourceMap文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;inlineSourceMap&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 生成目标文件的inline SourceMap，//inline SourceMap会包含在生成的js文件中</span></span><br><span class=\"line\"><span class=\"attr\">&quot;declarationMap&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 为声明文件生成sourceMap</span></span><br><span class=\"line\"><span class=\"attr\">&quot;typeRoots&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 声明文件目录，默认时node_modules/@types</span></span><br><span class=\"line\"><span class=\"attr\">&quot;types&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 加载的声明文件包</span></span><br><span class=\"line\">              <span class=\"comment\">//如果指定了某个值， 她会在 typeRoots 下找这个包，找到了就只加载这个包</span></span><br><span class=\"line\"><span class=\"attr\">&quot;removeComments&quot;</span><span class=\"punctuation\">:</span><span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 删除注释 </span></span><br><span class=\"line\"><span class=\"attr\">&quot;noEmit&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 不输出文件,即编译后不会生成任何js文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noEmitOnError&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 发送错误时不输出任何文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noEmitHelpers&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用</span></span><br><span class=\"line\"><span class=\"attr\">&quot;importHelpers&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 通过tslib引入helper函数，文件必须是模块</span></span><br><span class=\"line\"><span class=\"attr\">&quot;downlevelIteration&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现</span></span><br><span class=\"line\"><span class=\"attr\">&quot;strict&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 开启所有严格的类型检查</span></span><br><span class=\"line\"><span class=\"attr\">&quot;alwaysStrict&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 在代码中注入&#x27;use strict&#x27;</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noImplicitAny&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 不允许隐式的any类型</span></span><br><span class=\"line\"><span class=\"attr\">&quot;strictNullChecks&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 不允许把null、undefined赋值给其他类型的变量</span></span><br><span class=\"line\"><span class=\"attr\">&quot;strictFunctionTypes&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 不允许函数参数双向协变</span></span><br><span class=\"line\"><span class=\"attr\">&quot;strictPropertyInitialization&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 类的实例属性必须初始化</span></span><br><span class=\"line\"><span class=\"attr\">&quot;strictBindCallApply&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 严格的bind/call/apply检查</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noImplicitThis&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 不允许this有隐式的any类型</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noUnusedLocals&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 检查只声明、未使用的局部变量(只提示不报错)</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noUnusedParameters&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 检查未使用的函数参数(只提示不报错)</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noFallthroughCasesInSwitch&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 防止switch语句贯穿(即如果没有break语句后面不会执行)</span></span><br><span class=\"line\"><span class=\"attr\">&quot;noImplicitReturns&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">//每个分支都会有返回值</span></span><br><span class=\"line\"><span class=\"attr\">&quot;esModuleInterop&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 允许export=导出，由import from 导入</span></span><br><span class=\"line\"><span class=\"attr\">&quot;allowUmdGlobalAccess&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 允许在模块中全局变量的方式访问umd模块</span></span><br><span class=\"line\"><span class=\"attr\">&quot;moduleResolution&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;node&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 模块解析策略，ts默认用node的解析策略，即相对的方式导入</span></span><br><span class=\"line\"><span class=\"attr\">&quot;baseUrl&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;./&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 解析非相对模块的基地址，默认是当前目录</span></span><br><span class=\"line\"><span class=\"attr\">&quot;paths&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span> <span class=\"comment\">// 路径映射，相对于baseUrl</span></span><br><span class=\"line\">    <span class=\"comment\">// 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置</span></span><br><span class=\"line\">   <span class=\"attr\">&quot;jquery&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;node_modules/jquery/dist/jquery.min.js&quot;</span><span class=\"punctuation\">]</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;rootDirs&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;src&quot;</span><span class=\"punctuation\">,</span><span class=\"string\">&quot;out&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 将多个目录放在一个虚拟目录下，用于运行时，</span></span><br><span class=\"line\">                          <span class=\"comment\">//即编译后引入文件的位置可能发生变化，</span></span><br><span class=\"line\">                          <span class=\"comment\">//这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错</span></span><br><span class=\"line\"><span class=\"attr\">&quot;listEmittedFiles&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 打印输出文件</span></span><br><span class=\"line\"><span class=\"attr\">&quot;listFiles&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span> <span class=\"punctuation\">,</span> <span class=\"comment\">// 打印编译的文件(包括引用的声明文件)</span></span><br><span class=\"line\"><span class=\"attr\">&quot;jsx&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;Preserve&quot;</span>   <span class=\"comment\">//在 .tsx 中支持 JSX ：React 或 Preserve</span></span><br><span class=\"line\"><span class=\"attr\">&quot;jsxFactory&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;&quot;</span>   <span class=\"comment\">//默认值 React.createElement\t。  jsx 设置为 React 时使用的创建函数</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"typescript-中-const-和-readonly-的区别枚举和常量枚举的区别接口和类型别名的区别\"><a class=\"anchor\" href=\"#typescript-中-const-和-readonly-的区别枚举和常量枚举的区别接口和类型别名的区别\">#</a> <strong>TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？</strong></h1>\n<p><code>const 和 readonly</code> : const 可以防止变量的值被修改，readonly 关键字用于定义类中的只读属性。只读属性只能在声明时或构造函数中进行赋值，后续不能对其进行修改。</p>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PI</span> = <span class=\"number\">3.14</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable constant_\">PI</span>); <span class=\"comment\">// 输出: 3.14</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable constant_\">PI</span> = <span class=\"number\">3.14159</span>; <span class=\"comment\">// 报错: &quot;Cannot assign to &#x27;PI&#x27; because it is a constant.&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">changeName</span>(<span class=\"params\">newName: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = newName; <span class=\"comment\">// 报错: &quot;Cannot assign to &#x27;name&#x27; because it is a read-only property.&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">&#x27;Alice&#x27;</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(person.<span class=\"property\">name</span>); <span class=\"comment\">// 输出: &quot;Alice&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">person.<span class=\"property\">name</span> = <span class=\"string\">&#x27;Bob&#x27;</span>; <span class=\"comment\">// 报错: &quot;Cannot assign to &#x27;name&#x27; because it is a read-only property.&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p><code>枚举和常量枚举</code> ：常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。<br />\n <code>接口和类型别名</code> ：两者都可以用来描述对象或函数的类型。相同点：<br />\n\\1. 都可以描述 ' 对象 ' 或者 ' 函数'<br />\n\\2. 都允许拓展 (extends)</p>\n<p>不同点：<br />\n\\1. type 可以声明基本类型，联合类型，元组<br />\n \\2. type 可以使用 typeof 获取实例的类型进行赋值<br />\n \\3. 多个相同的 interface 声明可以自动合并</p>\n<p>与接口不同，类型别名还可以用于其他类型，如基本类型（原始值）、联合类型、元组。接口可用来实现，某个类可以实现接口，实现接口中所有的抽象类和方法</p>\n<h1 id=\"typescript-中-interface-可以给-function-array-classindexable做声明\"><a class=\"anchor\" href=\"#typescript-中-interface-可以给-function-array-classindexable做声明\">#</a> TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明</h1>\n<p>可以声明函数，数组，类</p>\n<blockquote>\n<p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 可以 */</span></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\">interface <span class=\"title class_\">Say</span> &#123;</span><br><span class=\"line\"> (<span class=\"attr\">name</span>: string): viod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">say</span>: <span class=\"title class_\">Say</span> = (<span class=\"attr\">name</span>: string):<span class=\"function\"><span class=\"params\">viod</span> =&gt;</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// Array 声明</span></span><br><span class=\"line\">interface <span class=\"title class_\">NumberArray</span> &#123; </span><br><span class=\"line\"> [<span class=\"attr\">index</span>: number]: number; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"attr\">fibonacci</span>: <span class=\"title class_\">NumberArray</span> = [<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"comment\">// Class 声明</span></span><br><span class=\"line\">interface <span class=\"title class_\">PersonalIntl</span> &#123;</span><br><span class=\"line\"> <span class=\"attr\">name</span>: string</span><br><span class=\"line\"> sayHi (<span class=\"attr\">name</span>: string): string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"typescript-如何设计-class-的声明\"><a class=\"anchor\" href=\"#typescript-如何设计-class-的声明\">#</a> TypeScript 如何设计 Class 的声明？</h1>\n<p>在类中声明属性或方法，使用 constructor 构造函数赋予初值</p>\n<blockquote>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Greeter</span> &#123;</span><br><span class=\"line\">   <span class=\"attr\">greeting</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">   <span class=\"title function_\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">       <span class=\"variable language_\">this</span>.<span class=\"property\">greeting</span> = message;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"title function_\">greet</span>(): <span class=\"built_in\">string</span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">greeting</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter = <span class=\"keyword\">new</span> <span class=\"title class_\">Greeter</span>(<span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 在声明类的时候，一般类中都会包含，构造函数、对构造函数中的属性进行类型声明、类中的方法。</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"typescript-中如何设置模块导入的路径别名\"><a class=\"anchor\" href=\"#typescript-中如何设置模块导入的路径别名\">#</a> TypeScript 中如何设置模块导入的路径别名？</h1>\n<blockquote>\n<p>通过 tsconfig.json 中的 paths 项来配置:</p>\n<p><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span><span class=\"punctuation\">:</span> </span><br><span class=\"line\">    <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">      <span class=\"attr\">&quot;baseUrl&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;.&quot;</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">      <span class=\"attr\">&quot;paths&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span> </span><br><span class=\"line\">         <span class=\"attr\">&quot;@helper/*&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;src/helper/*&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">         <span class=\"attr\">&quot;@utils/*&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;src/utils/*&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span> </span><br><span class=\"line\">         ... </span><br><span class=\"line\">      <span class=\"punctuation\">&#125;</span> </span><br><span class=\"line\">   <span class=\"punctuation\">&#125;</span> </span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"对-typescript-类中成员的-public-private-protected-readonly-修饰符的理解\"><a class=\"anchor\" href=\"#对-typescript-类中成员的-public-private-protected-readonly-修饰符的理解\">#</a> 对 TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解？</h1>\n<blockquote>\n<p><code>public</code> : 成员都默认为 <code>public</code> ，被此限定符修饰的成员是可以被外部访问；<br />\n <code>private</code> : 被此限定符修饰的成员是只可以被类的内部访问；<br />\n <code>protected</code> : 被此限定符修饰的成员是只可以被类的内部以及类的子类访问；<br />\n <code>readonly</code> : 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>\n</blockquote>\n<h1 id=\"数组定义的两种方式\"><a class=\"anchor\" href=\"#数组定义的两种方式\">#</a> 数组定义的两种方式</h1>\n<blockquote>\n<p><figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span>= <span class=\"title class_\">Array</span>&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Bar</span> &#123; </span><br><span class=\"line\">     <span class=\"attr\">baz</span>: <span class=\"title class_\">Array</span>&lt;&#123; <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">age</span>: <span class=\"built_in\">number</span>&#125;&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"title class_\">Foo</span> = <span class=\"built_in\">string</span>[];</span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">Bar</span> &#123; </span><br><span class=\"line\">     baz : &#123; <span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">age</span>: <span class=\"built_in\">number</span> &#125;[] </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"ts中的泛型是什么\"><a class=\"anchor\" href=\"#ts中的泛型是什么\">#</a> TS 中的泛型是什么？</h1>\n<p>泛型允许我们在编写代码时使用一些以后才指定的类型，在定义函数，接口或者类的时候，不预先定义好具体的类型，而在使用的时候在指定类型的一种特性。</p>\n<p>any 和泛型的区别？</p>\n<p>泛型有类型推论，编译器会根据传入的参数自动地帮助我们确定 T 的类型</p>\n<p>any 则是不检验</p>\n<h1 id=\"类的静态成员\"><a class=\"anchor\" href=\"#类的静态成员\">#</a> 类的静态成员</h1>\n<p>在 TypeScript 中，类可以拥有静态成员，它们属于类本身，而不是属于类的实例。静态成员可以通过  <code>static</code>  关键字来定义。下面是一个使用静态成员的例子：</p>\n<p><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Calculator</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"attr\">PI</span>: <span class=\"built_in\">number</span> = <span class=\"number\">3.1415926</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"title function_\">add</span>(<span class=\"attr\">x</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"title function_\">subtract</span>(<span class=\"attr\">x</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x - y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Calculator</span>.<span class=\"property\">PI</span>); <span class=\"comment\">// 输出：3.1415926</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Calculator</span>.<span class=\"title function_\">add</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>)); <span class=\"comment\">// 输出：3</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Calculator</span>.<span class=\"title function_\">subtract</span>(<span class=\"number\">4</span>, <span class=\"number\">2</span>)); <span class=\"comment\">// 输出：2</span></span><br></pre></td></tr></table></figure></p>\n<p>在这个例子中，我们定义了一个  <code>Calculator</code>  类，它有一个静态属性  <code>PI</code>  和两个静态方法  <code>add</code>  和  <code>subtract</code> 。这些成员可以在任何地方被调用，无需创建  <code>Calculator</code>  类的实例。</p>\n<h1 id=\"简单介绍一下-typescript-模块的加载机制\"><a class=\"anchor\" href=\"#简单介绍一下-typescript-模块的加载机制\">#</a> 简单介绍一下 TypeScript 模块的加载机制？</h1>\n<p>假设有一个导入语句  <code>import &#123; a &#125; from &quot;moduleA&quot;</code> ;</p>\n<ol>\n<li>首先，编译器会尝试定位需要导入的模块文件，通过绝对或者相对的路径查找方式；</li>\n<li>如果上面的解析失败了，没有查找到对应的模块，编译器会尝试定位一个 <code>外部模块声明</code> （.d.ts）；</li>\n<li>最后，如果编译器还是不能解析这个模块，则会抛出一个错误  <code>error TS2307: Cannot find module 'moduleA'.</code></li>\n</ol>\n",
            "tags": [
                "学习，ts"
            ]
        },
        {
            "id": "http://example.com/2024/05/28/vue%E7%B3%BB%E5%88%97/",
            "url": "http://example.com/2024/05/28/vue%E7%B3%BB%E5%88%97/",
            "title": "vue系列",
            "date_published": "2024-05-28T01:12:48.000Z",
            "content_html": "<h1 id=\"vue的生命周期\"><a class=\"anchor\" href=\"#vue的生命周期\">#</a> vue 的生命周期</h1>\n<p>​\tVue 生命周期总共可以分为 8 个阶段</p>\n<table>\n<thead>\n<tr>\n<th>beforeCreate</th>\n<th>组件实例被创建之初</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>created</td>\n<td>组件实例已经完全创建</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>组件挂载之前</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>组件挂载到实例上去之后</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>组件数据发生变化，更新之前</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>组件数据更新之后</td>\n</tr>\n<tr>\n<td>beforeDestroy</td>\n<td>组件实例销毁之前</td>\n</tr>\n<tr>\n<td>destroyed</td>\n<td>组件实例销毁之后</td>\n</tr>\n<tr>\n<td>activated</td>\n<td>keep-alive 缓存的组件激活时</td>\n</tr>\n<tr>\n<td>deactivated</td>\n<td>keep-alive 缓存的组件停用时调用</td>\n</tr>\n<tr>\n<td>errorCaptured</td>\n<td>捕获一个来自子孙组件的错误时被调用</td>\n</tr>\n</tbody>\n</table>\n<p>在 vue2 和 vue3 中的生命周期钩子函数有所不同：</p>\n<p>​\tvue3 中多了 setup 生命周期，所以 vue3 中的 created 和 beforecreate 换成了 setup，销毁换成了 onBeforeUnmount 和 onUnmounted。此外被包含在 &lt;keep-alive&gt; 中的组件，会多出两个生命周期钩子函数，被激活时执行 onActivated ，停用时执行 deactivated。</p>\n<h1 id=\"vue的响应式原理\"><a class=\"anchor\" href=\"#vue的响应式原理\">#</a> vue 的响应式原理</h1>\n<p>​\t在 vue2，和 vue3 中响应式原理时不同的。在 vue2 中使用的是 object.defineProperty 进行数据劫持的。</p>\n<h2 id=\"方法1objectdefineproperty实现\"><a class=\"anchor\" href=\"#方法1objectdefineproperty实现\">#</a> 方法 1.Object.defineProperty 实现</h2>\n<p>给数据赋予 <code>getter</code>  和 <code>setter</code> 。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> middle = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(data,<span class=\"string\">&#x27;age&#x27;</span>,&#123;</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;获取age&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">parmas</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//参数就是赋值的数据</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;修改age数据&#x27;</span>,parmas)</span><br><span class=\"line\">    middle = parmas</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span><br><span class=\"line\"><span class=\"comment\">// 取值的时候触发getter</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data.<span class=\"property\">age</span>)</span><br><span class=\"line\"><span class=\"comment\">//赋值的时候触发setter</span></span><br><span class=\"line\">data.<span class=\"property\">age</span> = <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data.<span class=\"property\">age</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>而每个 setter 方法就是一个观察者，在数据变更的时候通知订阅者更新视图。当数据发生变化时页面上的数据会实时改变，更新页面。但这种方法<strong>无法检测到对象属性的添加或删除</strong> (如 <code>data.location.a=1</code> )； <code>getter/setter</code>  只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。所以 ** <code>Object.defineProperty</code>  不能监听数组的变化，需要进行数组方法的重写 **</p>\n<h2 id=\"方法2proxy实现\"><a class=\"anchor\" href=\"#方法2proxy实现\">#</a> 方法 2.Proxy 实现</h2>\n<p>​\t <code>Proxy</code>  是 JavaScript 2015 的一个新特性。<strong> <code>Proxy</code>  的代理是针对整个对象的，而不是对象的某个属性</strong>， <code>Proxy</code>  只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，递归还是需要进行的。此外 ** <code>Proxy</code>  支持代理数组的变化。**</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;模拟视图的更新&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;前端工匠&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">100</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">arr</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果取的值是对象就在对这个对象进行数据劫持</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> target[key] == <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; target[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(target[key], handler)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, key)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">target, key, value</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;length&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, key, value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(obj, handler)</span><br><span class=\"line\">proxy.<span class=\"property\">age</span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;浪里行舟&#x27;</span> <span class=\"comment\">// 支持新增属性</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(proxy.<span class=\"property\">age</span>.<span class=\"property\">name</span>) <span class=\"comment\">// 模拟视图的更新 浪里行舟</span></span><br><span class=\"line\">proxy.<span class=\"property\">arr</span>[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;浪里行舟&#x27;</span> <span class=\"comment\">//支持数组的内容发生变化</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(proxy.<span class=\"property\">arr</span>) <span class=\"comment\">// 模拟视图的更新 [&#x27;浪里行舟&#x27;, 2, 3 ]</span></span><br><span class=\"line\">proxy.<span class=\"property\">arr</span>.<span class=\"property\">length</span>-- <span class=\"comment\">// 无效</span></span><br></pre></td></tr></table></figure></p>\n<p>getter 用来收集依赖 setter 用来监听变换改变视图。收集完依赖需要为依赖找一个存储依赖的地方，为此我们创建了 Dep, 它用来收集依赖、删除依赖和向依赖发送消息等。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dep</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 用来存放Watcher对象的数组 */</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span> = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 在subs中添加一个Watcher对象 */</span></span><br><span class=\"line\">    addSub (sub) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>.<span class=\"title function_\">push</span>(sub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 通知所有Watcher对象更新视图 */</span></span><br><span class=\"line\">    notify () &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">sub</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            sub.<span class=\"title function_\">update</span>();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"vue实现双向绑定\"><a class=\"anchor\" href=\"#vue实现双向绑定\">#</a> vue 实现双向绑定</h1>\n<p>vue 实现双向绑定是基于数据响应式。通过 <code>Object.defineProperty()</code>  来劫持各个属性的 <code>setter， getter</code> ，在数据发生变动时通知 Vue 实例，触发相应的 getter 和 setter 回调函数。vue 中的 v-model 是 v-on 和 v-bind 的语法糖。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=<span class=\"string\">&quot;xxx&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 上面的代码等价于 --&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">:value</span>=<span class=\"string\">&quot;xxx&quot;</span> @<span class=\"attr\">input</span>=<span class=\"string\">&quot;xxx = $event.target.value&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"comment\">&lt;!-- 双向绑定 = 单向绑定 + UI事件监听 --&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>:value 实现单向绑定，@input 绑定事件从而实现双向绑定</p>\n<p>要实现一个完整的双向绑定需要以下几个要点：</p>\n<ol>\n<li>利用 <code>Proxy</code>  或 <code>Object.defineProperty</code>  生成的 <code>Observer</code>  针对对象 / 对象的属性进行 &quot;劫持&quot;, 在属性发生变化后通知订阅者</li>\n<li>解析器 <code>Compile</code>  解析模板中的 <code>Directive</code>  (指令)，收集指令所依赖的方法和数据，等待数据变化然后进行渲染</li>\n<li><code>Watcher</code>  属于 <code>Observer</code>  和 <code>Compile</code>  桥梁，它将接收到的 <code>Observer</code>  产生的数据变化，并根据 <code>Compile</code>  提供的指令进行视图渲染，使得数据变化促使视图变化</li>\n</ol>\n<h1 id=\"vue如何解决跨域问题\"><a class=\"anchor\" href=\"#vue如何解决跨域问题\">#</a> vue 如何解决跨域问题</h1>\n<p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p>\n<p>所谓同源（即指在同一个域）具有以下三个相同点</p>\n<ul>\n<li>\n<p>协议相同（protocol）</p>\n</li>\n<li>\n<p>主机相同（host）</p>\n</li>\n<li>\n<p>端口相同（port）</p>\n<p><strong>方案一 (proxy 代理)</strong></p>\n<p>如果是通过 <code>vue-cli</code>  脚手架工具搭建项目，我们可以通过 <code>webpack</code>  为我们起一个本地服务器作为请求的代理对象</p>\n<p>在 <code>vue.config.js</code>  文件，新增以下代码</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">amodule.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">devServer</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">host</span>: <span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">port</span>: <span class=\"number\">8084</span>,</span><br><span class=\"line\">        <span class=\"attr\">open</span>: <span class=\"literal\">true</span>,<span class=\"comment\">// vue项目启动时自动打开浏览器</span></span><br><span class=\"line\">        <span class=\"attr\">proxy</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;/api&#x27;</span>: &#123; <span class=\"comment\">// &#x27;/api&#x27;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span><br><span class=\"line\">                <span class=\"attr\">target</span>: <span class=\"string\">&quot;http://xxx.xxx.xx.xx:8080&quot;</span>, <span class=\"comment\">//目标地址，一般是指后台服务器地址</span></span><br><span class=\"line\">                <span class=\"attr\">changeOrigin</span>: <span class=\"literal\">true</span>, <span class=\"comment\">//是否跨域</span></span><br><span class=\"line\">                <span class=\"attr\">pathRewrite</span>: &#123; <span class=\"comment\">// pathRewrite 的作用是把实际Request Url中的&#x27;/api&#x27;用&quot;&quot;代替</span></span><br><span class=\"line\">                    <span class=\"string\">&#x27;^/api&#x27;</span>: <span class=\"string\">&quot;&quot;</span> </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果是生产环境可以配置 nginx 的代理和上述方式类似</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen    <span class=\"number\">80</span>;</span><br><span class=\"line\">    # server_name www.<span class=\"property\">josephxia</span>.<span class=\"property\">com</span>;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root  /<span class=\"keyword\">var</span>/www/html;</span><br><span class=\"line\">        index  index.<span class=\"property\">html</span> index.<span class=\"property\">htm</span>;</span><br><span class=\"line\">        try_files $uri $uri/ /index.<span class=\"property\">html</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    location /api &#123;</span><br><span class=\"line\">        proxy_pass  <span class=\"attr\">http</span>:<span class=\"comment\">//127.0.0.1:3000;</span></span><br><span class=\"line\">        proxy_redirect   off;</span><br><span class=\"line\">        proxy_set_header  <span class=\"title class_\">Host</span>       $host;</span><br><span class=\"line\">        proxy_set_header  X-<span class=\"title class_\">Real</span>-<span class=\"variable constant_\">IP</span>     $remote_addr;</span><br><span class=\"line\">        proxy_set_header  X-<span class=\"title class_\">Forwarded</span>-<span class=\"title class_\">For</span>  $proxy_add_x_forwarded_for;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>方案二 (CORS)</strong></p>\n<p>它由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</p>\n<p>后端在接受前端请求后先前端发送数据时在 http 请求头中直接设置 <code>Access-Control-Allow-Origin</code>  响应头如：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"keyword\">async</span> (ctx, next)=&gt; &#123;</span><br><span class=\"line\">  ctx.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class=\"string\">&#x27;*&#x27;</span>);</span><br><span class=\"line\">  ctx.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class=\"string\">&#x27;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#x27;</span>);</span><br><span class=\"line\">  ctx.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class=\"string\">&#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ctx.<span class=\"property\">method</span> == <span class=\"string\">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class=\"line\">    ctx.<span class=\"property\">body</span> = <span class=\"number\">200</span>; </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">next</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>方案三 (JSONP)</strong></p>\n<p>事先定义一个用于获取跨域响应数据的回调函数，并通过没有同源策略限制的 <code>script</code>  标签发起一个请求（将回调函数的名称放到这个请求的 <code>query</code>  参数里），然后服务端返回这个回调函数的执行，并将需要响应的数据放到回调函数的参数里，</p>\n<p>优点</p>\n<ul>\n<li>\n<p>它不像 <code>XMLHttpRequest</code>  对象实现的 <code>Ajax</code>  请求那样受到同源策略的限制</p>\n</li>\n<li>\n<p>它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 <code>XMLHttpRequest</code>  或 <code>ActiveX</code>  的支持</p>\n</li>\n<li>\n<p>并且在请求完毕后可以通过调用 <code>callback</code>  的方式回传结果</p>\n<p>用 jsonp 的好处是可以单独让一个 http 请求跨域</p>\n</li>\n</ul>\n<p>缺点：</p>\n<p>​\t它<strong>只支持 <code>GET</code>  请求</strong>而不支持  <code>POST</code>  等其它类型的 HTTP 请求</p>\n</li>\n</ul>\n<h1 id=\"vue的diff算法\"><a class=\"anchor\" href=\"#vue的diff算法\">#</a> vue 的 diff 算法</h1>\n<p><code>diff</code>  算法是一种通过同层的树节点进行比较的高效算法</p>\n<p>其有两个特点：</p>\n<ul>\n<li>\n<p>比较只会在同层级进行，不会跨层级比较</p>\n</li>\n<li>\n<p>在 diff 比较的过程中，循环从两边向中间比较</p>\n<p>当数据发生改变时， <code>set</code>  方法会调用 <code>Dep.notify</code>  通知所有订阅者 <code>Watcher</code> ，订阅者就会调用 <code>patch</code>  给真实的 <code>DOM</code>  打补丁，更新相应的视图</p>\n</li>\n<li>\n<p>当数据发生改变时，订阅者 <code>watcher</code>  就会调用 <code>patch</code>  给真实的 <code>DOM</code>  打补丁</p>\n</li>\n<li>\n<p>通过 <code>isSameVnode</code>  进行判断，相同则调用 <code>patchVnode</code>  方法</p>\n<p>patchVnode 做了以下操作：</p>\n<p>找到对应的真实 <code>dom</code> ，称为 <code>el</code></p>\n<ul>\n<li>如果都有都有文本节点且不相等，将 <code>el</code>  文本节点设置为 <code>Vnode</code>  的文本节点</li>\n<li>如果 <code>oldVnode</code>  有子节点而 <code>VNode</code>  没有，则删除 <code>el</code>  子节点</li>\n<li>如果 <code>oldVnode</code>  没有子节点而 <code>VNode</code>  有，则将 <code>VNode</code>  的子节点真实化后添加到 <code>el</code></li>\n<li>如果两者都有子节点，则执行 <code>updateChildren</code>  函数比较子节点</li>\n</ul>\n<p>updateChildren 主要做了以下操作：</p>\n<ul>\n<li>\n<p>设置新旧 <code>VNode</code>  的头尾指针</p>\n</li>\n<li>\n<p>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用 <code>patchVnode</code>  进行 <code>patch</code>  重复流程、调用 <code>createElem</code>  创建一个新节点，从哈希表寻找  <code>key</code>  一致的 <code>VNode</code>  节点再分情况操作</p>\n<p><code>diff</code>  算法是一种通过同层的树节点进行比较的高效算法</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"vue2和vue3的区别\"><a class=\"anchor\" href=\"#vue2和vue3的区别\">#</a> vue2 和 vue3 的区别</h1>\n<ul>\n<li>响应式原理 api 的改变<br />\n Vue2 响应式原理采用的是 defineProperty，而 vue3 选用的是 proxy。这两者前者是修改对象属性的权限标签，后者是代理整个对象。性能上 proxy 会更加优秀。</li>\n<li>diff 算法，渲染算法的改变<br />\n Vue3 优化 diff 算法。不再像 vue2 那样比对所有 dom，而采用了 block tree 的做法。此外重新渲染的算法里也做了改进，利用了闭包来进行缓存。这使得 vue3 的速度比 vue2 快了 6 倍。</li>\n<li>建立数据 data<br />\n 这里就是 Vue2 与 Vue3 最大的区别 — Vue2 使用 <code>选项类型API（Options API）</code> 对比 Vue3 <code>合成型API（Composition API）</code>  旧的选项型 API 在代码里分割了不同的属性（properties）：data，computed 属性，methods，等等。新的合成型 API 能让我们用方法（function）来分割，相比于旧的 API 使用属性来分组，这样代码会更加简便和整洁。</li>\n<li>**Diff 算法重写：** 新增了最长递归子序列的<a href=\"https://so.csdn.net/so/search?q=%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020\">算法</a>，来计算出最小的修改偏移量。还增加了静态标记</li>\n</ul>\n<h1 id=\"v-show与v-if的区别\"><a class=\"anchor\" href=\"#v-show与v-if的区别\">#</a> v-show 与 v-if 的区别</h1>\n<p>控制手段： <code>v-show</code>  隐藏则是为该元素添加 <code>css--display:none</code> ， <code>dom</code>  元素依旧还在。 <code>v-if</code>  显示隐藏是将 <code>dom</code>  元素整个添加或删除</p>\n<p>编译过程： <code>v-if</code>  切换有一个局部编译 / 卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件； <code>v-show</code>  只是简单的基于 css 切换</p>\n<p>v-show 有 <code>transition</code>  就执行 <code>transition</code> ，没有就直接设置 <code>display</code>  属性</p>\n<p>返回一个 <code>node</code>  节点， <code>render</code>  函数通过表达式的值来决定是否生成 <code>DOM</code></p>\n<h1 id=\"前端性能优化\"><a class=\"anchor\" href=\"#前端性能优化\">#</a> 前端性能优化</h1>\n<ul>\n<li>\n<p><code>减少HTTP请求</code> <br />\n如 Chrome 浏览器最多同时允许对同一个域名 Host 建立 6 个 TCP 连接，不同的浏览器有所区别，减少 http 请求也就是减少我们 html 里 css/js 等资源的数量</p>\n</li>\n<li>\n<p><code>设置浏览器缓存策略</code> 主要为设置缓存策略：</p>\n<ul>\n<li>\n<p>强制缓存：当 web 应用获取资源时，先从 本地 获取，如果有就直接用。强制缓存涉及到的头字段有  <code>Expires</code> （http1.0）和 <code>Cache-Control</code>  (http1.1)，由服务端设置.</p>\n</li>\n<li>\n<p>Expires 接受一个 GMT 格式时间</p>\n</li>\n<li>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token literal-property property\">Expires</span><span class=\"token operator\">:</span> Wed<span class=\"token punctuation\">,</span> <span class=\"token number\">21</span> Oct <span class=\"token number\">2015</span> <span class=\"token number\">07</span><span class=\"token operator\">:</span><span class=\"token number\">28</span><span class=\"token operator\">:</span><span class=\"token number\">00</span> <span class=\"token constant\">GMT</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>code￼<span class=\"token number\">7</span><span class=\"token operator\">--</span><span class=\"token operator\">></span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p><code>createElement</code>  创建  <code>VNode</code>  的过程，每个  <code>VNode</code>  有  <code>children</code> ， <code>children</code>  每个元素也是一个 <code>VNode</code> ，这样就形成了一个虚拟树结构，用于描述真实的 <code>DOM</code>  树结构</p>\n<h1 id=\"组件间通信的方案\"><a class=\"anchor\" href=\"#组件间通信的方案\">#</a> 组件间通信的方案</h1>\n<ol>\n<li>\n<p>通过 props 传递</p>\n<ul>\n<li>适用场景：父组件传递数据给子组件</li>\n<li>子组件设置 <code>props</code>  属性，定义接收父组件传递过来的参数，父组件在使用子组件标签中通过字面量来传递值</li>\n</ul>\n</li>\n<li>\n<p>通过 $emit 触发自定义事件</p>\n<ul>\n<li>适用场景：子组件传递数据给父组件</li>\n<li>子组件通过 <code>$emit触发</code> 自定义事件， <code>$emit</code>  第二个参数为传递的数值，父组件绑定监听器获取到子组件传递过来的参数</li>\n</ul>\n</li>\n<li>\n<p>EventBus</p>\n<ul>\n<li>使用场景：兄弟组件传值</li>\n<li>创建一个中央事件总线 <code>EventBus</code></li>\n<li>兄弟组件通过 <code>$emit</code>  触发自定义事件， <code>$emit</code>  第二个参数为传递的数值，另一个兄弟组件通过 <code>$on</code>  监听自定义事件</li>\n</ul>\n</li>\n<li>\n<p>Provide 与 Inject</p>\n<ol>\n<li>\n<p>在祖先组件定义 <code>provide</code>  属性，返回传递的值</p>\n</li>\n<li>\n<p>在后代组件通过 <code>inject</code>  接收组件传递过来的值</p>\n</li>\n<li>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">provide</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>  </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">&#123;</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token literal-property property\">foo</span><span class=\"token operator\">:</span><span class=\"token string\">'foo'</span>  </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span>  </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span>  </pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token literal-property property\">inject</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 获取到祖先组件传递过来的值</span></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li>\n<p>Vuex</p>\n</li>\n</ol>\n<h1 id=\"vue中key的原理吗\"><a class=\"anchor\" href=\"#vue中key的原理吗\">#</a> vue 中 key 的原理吗</h1>\n<ol>\n<li>当我们在使用 <code>v-for</code>  时，需要给单元加上 <code>key</code></li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in items&quot;</span> <span class=\"attr\">:key</span>=<span class=\"string\">&quot;item.id&quot;</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>用 <code>+new Date()</code>  生成的时间戳作为 <code>key</code> ，手动强制触发重新渲染</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Comp</span> :key=<span class=\"string\">&quot;+new Date()&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在不使用 <code>key</code>  的情况，vue 会原地复用修改 DOM 值增加 DOM 操作</p>\n<p>设置 key 值不一定能提高 diff 效率。</p>\n",
            "tags": []
        }
    ]
}