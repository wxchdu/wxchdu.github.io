{
    "version": "https://jsonfeed.org/version/1",
    "title": "worked warriors • All posts by \"平时学习\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2024/05/28/vue%E7%B3%BB%E5%88%97/",
            "url": "http://example.com/2024/05/28/vue%E7%B3%BB%E5%88%97/",
            "title": "vue系列",
            "date_published": "2024-05-28T01:12:48.000Z",
            "content_html": "<h1 id=\"vue相关面试问题\"><a class=\"anchor\" href=\"#vue相关面试问题\">#</a> vue 相关面试问题</h1>\n<h2 id=\"vue的生命周期\"><a class=\"anchor\" href=\"#vue的生命周期\">#</a> vue 的生命周期</h2>\n<p>​\tVue 生命周期总共可以分为 8 个阶段</p>\n<table>\n<thead>\n<tr>\n<th>beforeCreate</th>\n<th>组件实例被创建之初</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>created</td>\n<td>组件实例已经完全创建</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>组件挂载之前</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>组件挂载到实例上去之后</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>组件数据发生变化，更新之前</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>组件数据更新之后</td>\n</tr>\n<tr>\n<td>beforeDestroy</td>\n<td>组件实例销毁之前</td>\n</tr>\n<tr>\n<td>destroyed</td>\n<td>组件实例销毁之后</td>\n</tr>\n<tr>\n<td>activated</td>\n<td>keep-alive 缓存的组件激活时</td>\n</tr>\n<tr>\n<td>deactivated</td>\n<td>keep-alive 缓存的组件停用时调用</td>\n</tr>\n<tr>\n<td>errorCaptured</td>\n<td>捕获一个来自子孙组件的错误时被调用</td>\n</tr>\n</tbody>\n</table>\n<p>在 vue2 和 vue3 中的生命周期钩子函数有所不同：</p>\n<p>​\tvue3 中多了 setup 生命周期，所以 vue3 中的 created 和 beforecreate 换成了 setup，销毁换成了 onBeforeUnmount 和 onUnmounted。此外被包含在 &lt;keep-alive&gt; 中的组件，会多出两个生命周期钩子函数，被激活时执行 onActivated ，停用时执行 deactivated。</p>\n<h2 id=\"vue的响应式原理\"><a class=\"anchor\" href=\"#vue的响应式原理\">#</a> vue 的响应式原理</h2>\n<p>​\t在 vue2，和 vue3 中响应式原理时不同的。在 vue2 中使用的是 object.defineProperty 进行数据劫持的。</p>\n<h3 id=\"方法1objectdefineproperty实现\"><a class=\"anchor\" href=\"#方法1objectdefineproperty实现\">#</a> 方法 1.Object.defineProperty 实现</h3>\n<p>给数据赋予 <code>getter</code>  和 <code>setter</code> 。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> middle = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"title class_\">Object</span>.<span class=\"title function_\">defineProperty</span>(data,<span class=\"string\">&#x27;age&#x27;</span>,&#123;</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\"></span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;获取age&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> middle</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">parmas</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//参数就是赋值的数据</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;修改age数据&#x27;</span>,parmas)</span><br><span class=\"line\">    middle = parmas</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data)</span><br><span class=\"line\"><span class=\"comment\">// 取值的时候触发getter</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data.<span class=\"property\">age</span>)</span><br><span class=\"line\"><span class=\"comment\">//赋值的时候触发setter</span></span><br><span class=\"line\">data.<span class=\"property\">age</span> = <span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data.<span class=\"property\">age</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>而每个 setter 方法就是一个观察者，在数据变更的时候通知订阅者更新视图。当数据发生变化时页面上的数据会实时改变，更新页面。但这种方法<strong>无法检测到对象属性的添加或删除</strong> (如 <code>data.location.a=1</code> )； <code>getter/setter</code>  只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。所以 ** <code>Object.defineProperty</code>  不能监听数组的变化，需要进行数组方法的重写 **</p>\n<h3 id=\"方法2proxy实现\"><a class=\"anchor\" href=\"#方法2proxy实现\">#</a> 方法 2.Proxy 实现</h3>\n<p>​\t <code>Proxy</code>  是 JavaScript 2015 的一个新特性。<strong> <code>Proxy</code>  的代理是针对整个对象的，而不是对象的某个属性</strong>， <code>Proxy</code>  只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，递归还是需要进行的。此外 ** <code>Proxy</code>  支持代理数组的变化。**</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">render</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;模拟视图的更新&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">&#x27;前端工匠&#x27;</span>,</span><br><span class=\"line\">  <span class=\"attr\">age</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">100</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">arr</span>: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> handler = &#123;</span><br><span class=\"line\">  <span class=\"title function_\">get</span>(<span class=\"params\">target, key</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果取的值是对象就在对这个对象进行数据劫持</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> target[key] == <span class=\"string\">&#x27;object&#x27;</span> &amp;&amp; target[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(target[key], handler)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">get</span>(target, key)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"title function_\">set</span>(<span class=\"params\">target, key, value</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key === <span class=\"string\">&#x27;length&#x27;</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"title function_\">render</span>()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"title class_\">Reflect</span>.<span class=\"title function_\">set</span>(target, key, value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> proxy = <span class=\"keyword\">new</span> <span class=\"title class_\">Proxy</span>(obj, handler)</span><br><span class=\"line\">proxy.<span class=\"property\">age</span>.<span class=\"property\">name</span> = <span class=\"string\">&#x27;浪里行舟&#x27;</span> <span class=\"comment\">// 支持新增属性</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(proxy.<span class=\"property\">age</span>.<span class=\"property\">name</span>) <span class=\"comment\">// 模拟视图的更新 浪里行舟</span></span><br><span class=\"line\">proxy.<span class=\"property\">arr</span>[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;浪里行舟&#x27;</span> <span class=\"comment\">//支持数组的内容发生变化</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(proxy.<span class=\"property\">arr</span>) <span class=\"comment\">// 模拟视图的更新 [&#x27;浪里行舟&#x27;, 2, 3 ]</span></span><br><span class=\"line\">proxy.<span class=\"property\">arr</span>.<span class=\"property\">length</span>-- <span class=\"comment\">// 无效</span></span><br></pre></td></tr></table></figure></p>\n<p>getter 用来收集依赖 setter 用来监听变换改变视图。收集完依赖需要为依赖找一个存储依赖的地方，为此我们创建了 Dep, 它用来收集依赖、删除依赖和向依赖发送消息等。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dep</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">constructor</span> () &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 用来存放Watcher对象的数组 */</span></span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span> = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 在subs中添加一个Watcher对象 */</span></span><br><span class=\"line\">    addSub (sub) &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>.<span class=\"title function_\">push</span>(sub);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* 通知所有Watcher对象更新视图 */</span></span><br><span class=\"line\">    notify () &#123;</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">subs</span>.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">sub</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            sub.<span class=\"title function_\">update</span>();</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"vue实现双向绑定\"><a class=\"anchor\" href=\"#vue实现双向绑定\">#</a> vue 实现双向绑定</h2>\n<p>vue 实现双向绑定是基于数据响应式。通过 <code>Object.defineProperty()</code>  来劫持各个属性的 <code>setter， getter</code> ，在数据发生变动时通知 Vue 实例，触发相应的 getter 和 setter 回调函数。vue 中的 v-model 是 v-on 和 v-bind 的语法糖。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input v-model=<span class=\"string\">&quot;xxx&quot;</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 上面的代码等价于 --&gt;</span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">:value</span>=<span class=\"string\">&quot;xxx&quot;</span> @<span class=\"attr\">input</span>=<span class=\"string\">&quot;xxx = $event.target.value&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\"><span class=\"comment\">&lt;!-- 双向绑定 = 单向绑定 + UI事件监听 --&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>:value 实现单向绑定，@input 绑定事件从而实现双向绑定</p>\n<p>要实现一个完整的双向绑定需要以下几个要点：</p>\n<ol>\n<li>利用 <code>Proxy</code>  或 <code>Object.defineProperty</code>  生成的 <code>Observer</code>  针对对象 / 对象的属性进行 &quot;劫持&quot;, 在属性发生变化后通知订阅者</li>\n<li>解析器 <code>Compile</code>  解析模板中的 <code>Directive</code>  (指令)，收集指令所依赖的方法和数据，等待数据变化然后进行渲染</li>\n<li><code>Watcher</code>  属于 <code>Observer</code>  和 <code>Compile</code>  桥梁，它将接收到的 <code>Observer</code>  产生的数据变化，并根据 <code>Compile</code>  提供的指令进行视图渲染，使得数据变化促使视图变化</li>\n</ol>\n<h2 id=\"vue如何解决跨域问题\"><a class=\"anchor\" href=\"#vue如何解决跨域问题\">#</a> vue 如何解决跨域问题</h2>\n<p>跨域本质是浏览器基于<strong>同源策略</strong>的一种安全手段</p>\n<p>所谓同源（即指在同一个域）具有以下三个相同点</p>\n<ul>\n<li>\n<p>协议相同（protocol）</p>\n</li>\n<li>\n<p>主机相同（host）</p>\n</li>\n<li>\n<p>端口相同（port）</p>\n<p><strong>方案一 (proxy 代理)</strong></p>\n<p>如果是通过 <code>vue-cli</code>  脚手架工具搭建项目，我们可以通过 <code>webpack</code>  为我们起一个本地服务器作为请求的代理对象</p>\n<p>在 <code>vue.config.js</code>  文件，新增以下代码</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">amodule.<span class=\"property\">exports</span> = &#123;</span><br><span class=\"line\">    <span class=\"attr\">devServer</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">host</span>: <span class=\"string\">&#x27;127.0.0.1&#x27;</span>,</span><br><span class=\"line\">        <span class=\"attr\">port</span>: <span class=\"number\">8084</span>,</span><br><span class=\"line\">        <span class=\"attr\">open</span>: <span class=\"literal\">true</span>,<span class=\"comment\">// vue项目启动时自动打开浏览器</span></span><br><span class=\"line\">        <span class=\"attr\">proxy</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;/api&#x27;</span>: &#123; <span class=\"comment\">// &#x27;/api&#x27;是代理标识，用于告诉node，url前面是/api的就是使用代理的</span></span><br><span class=\"line\">                <span class=\"attr\">target</span>: <span class=\"string\">&quot;http://xxx.xxx.xx.xx:8080&quot;</span>, <span class=\"comment\">//目标地址，一般是指后台服务器地址</span></span><br><span class=\"line\">                <span class=\"attr\">changeOrigin</span>: <span class=\"literal\">true</span>, <span class=\"comment\">//是否跨域</span></span><br><span class=\"line\">                <span class=\"attr\">pathRewrite</span>: &#123; <span class=\"comment\">// pathRewrite 的作用是把实际Request Url中的&#x27;/api&#x27;用&quot;&quot;代替</span></span><br><span class=\"line\">                    <span class=\"string\">&#x27;^/api&#x27;</span>: <span class=\"string\">&quot;&quot;</span> </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果是生产环境可以配置 nginx 的代理和上述方式类似</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen    <span class=\"number\">80</span>;</span><br><span class=\"line\">    # server_name www.<span class=\"property\">josephxia</span>.<span class=\"property\">com</span>;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root  /<span class=\"keyword\">var</span>/www/html;</span><br><span class=\"line\">        index  index.<span class=\"property\">html</span> index.<span class=\"property\">htm</span>;</span><br><span class=\"line\">        try_files $uri $uri/ /index.<span class=\"property\">html</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    location /api &#123;</span><br><span class=\"line\">        proxy_pass  <span class=\"attr\">http</span>:<span class=\"comment\">//127.0.0.1:3000;</span></span><br><span class=\"line\">        proxy_redirect   off;</span><br><span class=\"line\">        proxy_set_header  <span class=\"title class_\">Host</span>       $host;</span><br><span class=\"line\">        proxy_set_header  X-<span class=\"title class_\">Real</span>-<span class=\"variable constant_\">IP</span>     $remote_addr;</span><br><span class=\"line\">        proxy_set_header  X-<span class=\"title class_\">Forwarded</span>-<span class=\"title class_\">For</span>  $proxy_add_x_forwarded_for;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>方案二 (CORS)</strong></p>\n<p>它由一系列传输的 HTTP 头组成，这些 HTTP 头决定浏览器是否阻止前端 JavaScript 代码获取跨域请求的响应</p>\n<p>后端在接受前端请求后先前端发送数据时在 http 请求头中直接设置 <code>Access-Control-Allow-Origin</code>  响应头如：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.<span class=\"title function_\">use</span>(<span class=\"keyword\">async</span> (ctx, next)=&gt; &#123;</span><br><span class=\"line\">  ctx.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class=\"string\">&#x27;*&#x27;</span>);</span><br><span class=\"line\">  ctx.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class=\"string\">&#x27;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#x27;</span>);</span><br><span class=\"line\">  ctx.<span class=\"title function_\">set</span>(<span class=\"string\">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class=\"string\">&#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ctx.<span class=\"property\">method</span> == <span class=\"string\">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class=\"line\">    ctx.<span class=\"property\">body</span> = <span class=\"number\">200</span>; </span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">next</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>方案三 (JSONP)</strong></p>\n<p>事先定义一个用于获取跨域响应数据的回调函数，并通过没有同源策略限制的 <code>script</code>  标签发起一个请求（将回调函数的名称放到这个请求的 <code>query</code>  参数里），然后服务端返回这个回调函数的执行，并将需要响应的数据放到回调函数的参数里，</p>\n<p>优点</p>\n<ul>\n<li>\n<p>它不像 <code>XMLHttpRequest</code>  对象实现的 <code>Ajax</code>  请求那样受到同源策略的限制</p>\n</li>\n<li>\n<p>它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 <code>XMLHttpRequest</code>  或 <code>ActiveX</code>  的支持</p>\n</li>\n<li>\n<p>并且在请求完毕后可以通过调用 <code>callback</code>  的方式回传结果</p>\n<p>用 jsonp 的好处是可以单独让一个 http 请求跨域</p>\n</li>\n</ul>\n<p>缺点：</p>\n<p>​\t它<strong>只支持 <code>GET</code>  请求</strong>而不支持  <code>POST</code>  等其它类型的 HTTP 请求</p>\n</li>\n</ul>\n<h2 id=\"vue的diff算法\"><a class=\"anchor\" href=\"#vue的diff算法\">#</a> vue 的 diff 算法</h2>\n<p><code>diff</code>  算法是一种通过同层的树节点进行比较的高效算法</p>\n<p>其有两个特点：</p>\n<ul>\n<li>\n<p>比较只会在同层级进行，不会跨层级比较</p>\n</li>\n<li>\n<p>在 diff 比较的过程中，循环从两边向中间比较</p>\n<p>当数据发生改变时， <code>set</code>  方法会调用 <code>Dep.notify</code>  通知所有订阅者 <code>Watcher</code> ，订阅者就会调用 <code>patch</code>  给真实的 <code>DOM</code>  打补丁，更新相应的视图</p>\n</li>\n<li>\n<p>当数据发生改变时，订阅者 <code>watcher</code>  就会调用 <code>patch</code>  给真实的 <code>DOM</code>  打补丁</p>\n</li>\n<li>\n<p>通过 <code>isSameVnode</code>  进行判断，相同则调用 <code>patchVnode</code>  方法</p>\n<p>patchVnode 做了以下操作：</p>\n<p>找到对应的真实 <code>dom</code> ，称为 <code>el</code></p>\n<ul>\n<li>如果都有都有文本节点且不相等，将 <code>el</code>  文本节点设置为 <code>Vnode</code>  的文本节点</li>\n<li>如果 <code>oldVnode</code>  有子节点而 <code>VNode</code>  没有，则删除 <code>el</code>  子节点</li>\n<li>如果 <code>oldVnode</code>  没有子节点而 <code>VNode</code>  有，则将 <code>VNode</code>  的子节点真实化后添加到 <code>el</code></li>\n<li>如果两者都有子节点，则执行 <code>updateChildren</code>  函数比较子节点</li>\n</ul>\n<p>updateChildren 主要做了以下操作：</p>\n<ul>\n<li>\n<p>设置新旧 <code>VNode</code>  的头尾指针</p>\n</li>\n<li>\n<p>新旧头尾指针进行比较，循环向中间靠拢，根据情况调用 <code>patchVnode</code>  进行 <code>patch</code>  重复流程、调用 <code>createElem</code>  创建一个新节点，从哈希表寻找  <code>key</code>  一致的 <code>VNode</code>  节点再分情况操作</p>\n<p><code>diff</code>  算法是一种通过同层的树节点进行比较的高效算法</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"vue2和vue3的区别\"><a class=\"anchor\" href=\"#vue2和vue3的区别\">#</a> vue2 和 vue3 的区别</h2>\n<ul>\n<li>响应式原理 api 的改变<br />\n Vue2 响应式原理采用的是 defineProperty，而 vue3 选用的是 proxy。这两者前者是修改对象属性的权限标签，后者是代理整个对象。性能上 proxy 会更加优秀。</li>\n<li>diff 算法，渲染算法的改变<br />\n Vue3 优化 diff 算法。不再像 vue2 那样比对所有 dom，而采用了 block tree 的做法。此外重新渲染的算法里也做了改进，利用了闭包来进行缓存。这使得 vue3 的速度比 vue2 快了 6 倍。</li>\n<li>建立数据 data<br />\n 这里就是 Vue2 与 Vue3 最大的区别 — Vue2 使用 <code>选项类型API（Options API）</code> 对比 Vue3 <code>合成型API（Composition API）</code>  旧的选项型 API 在代码里分割了不同的属性（properties）：data，computed 属性，methods，等等。新的合成型 API 能让我们用方法（function）来分割，相比于旧的 API 使用属性来分组，这样代码会更加简便和整洁。</li>\n<li>**Diff 算法重写：** 新增了最长递归子序列的<a href=\"https://so.csdn.net/so/search?q=%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020\">算法</a>，来计算出最小的修改偏移量。还增加了静态标记</li>\n</ul>\n<h2 id=\"v-show与v-if的区别\"><a class=\"anchor\" href=\"#v-show与v-if的区别\">#</a> v-show 与 v-if 的区别</h2>\n<p>控制手段： <code>v-show</code>  隐藏则是为该元素添加 <code>css--display:none</code> ， <code>dom</code>  元素依旧还在。 <code>v-if</code>  显示隐藏是将 <code>dom</code>  元素整个添加或删除</p>\n<p>编译过程： <code>v-if</code>  切换有一个局部编译 / 卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件； <code>v-show</code>  只是简单的基于 css 切换</p>\n<p>v-show 有 <code>transition</code>  就执行 <code>transition</code> ，没有就直接设置 <code>display</code>  属性</p>\n<p>返回一个 <code>node</code>  节点， <code>render</code>  函数通过表达式的值来决定是否生成 <code>DOM</code></p>\n<h2 id=\"前端性能优化\"><a class=\"anchor\" href=\"#前端性能优化\">#</a> 前端性能优化</h2>\n<ul>\n<li>\n<p><code>减少HTTP请求</code> <br />\n如 Chrome 浏览器最多同时允许对同一个域名 Host 建立 6 个 TCP 连接，不同的浏览器有所区别，减少 http 请求也就是减少我们 html 里 css/js 等资源的数量</p>\n</li>\n<li>\n<p><code>设置浏览器缓存策略</code> 主要为设置缓存策略：</p>\n<ul>\n<li>\n<p>强制缓存：当 web 应用获取资源时，先从 本地 获取，如果有就直接用。强制缓存涉及到的头字段有  <code>Expires</code> （http1.0）和 <code>Cache-Control</code>  (http1.1)，由服务端设置.</p>\n</li>\n<li>\n<p>Expires 接受一个 GMT 格式时间</p>\n</li>\n<li>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token literal-property property\">Expires</span><span class=\"token operator\">:</span> Wed<span class=\"token punctuation\">,</span> <span class=\"token number\">21</span> Oct <span class=\"token number\">2015</span> <span class=\"token number\">07</span><span class=\"token operator\">:</span><span class=\"token number\">28</span><span class=\"token operator\">:</span><span class=\"token number\">00</span> <span class=\"token constant\">GMT</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span>code￼<span class=\"token number\">7</span><span class=\"token operator\">--</span><span class=\"token operator\">></span></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p><code>createElement</code>  创建  <code>VNode</code>  的过程，每个  <code>VNode</code>  有  <code>children</code> ， <code>children</code>  每个元素也是一个 <code>VNode</code> ，这样就形成了一个虚拟树结构，用于描述真实的 <code>DOM</code>  树结构</p>\n<h2 id=\"组件间通信的方案\"><a class=\"anchor\" href=\"#组件间通信的方案\">#</a> 组件间通信的方案</h2>\n<ol>\n<li>\n<p>通过 props 传递</p>\n<ul>\n<li>适用场景：父组件传递数据给子组件</li>\n<li>子组件设置 <code>props</code>  属性，定义接收父组件传递过来的参数，父组件在使用子组件标签中通过字面量来传递值</li>\n</ul>\n</li>\n<li>\n<p>通过 $emit 触发自定义事件</p>\n<ul>\n<li>适用场景：子组件传递数据给父组件</li>\n<li>子组件通过 <code>$emit触发</code> 自定义事件， <code>$emit</code>  第二个参数为传递的数值，父组件绑定监听器获取到子组件传递过来的参数</li>\n</ul>\n</li>\n<li>\n<p>EventBus</p>\n<ul>\n<li>使用场景：兄弟组件传值</li>\n<li>创建一个中央事件总线 <code>EventBus</code></li>\n<li>兄弟组件通过 <code>$emit</code>  触发自定义事件， <code>$emit</code>  第二个参数为传递的数值，另一个兄弟组件通过 <code>$on</code>  监听自定义事件</li>\n</ul>\n</li>\n<li>\n<p>Provide 与 Inject</p>\n<ol>\n<li>\n<p>在祖先组件定义 <code>provide</code>  属性，返回传递的值</p>\n</li>\n<li>\n<p>在后代组件通过 <code>inject</code>  接收组件传递过来的值</p>\n</li>\n<li>\n<figure class=\"highlight js\"><figcaption data-lang=\"JavaScript\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">provide</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>  </pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">&#123;</span>  </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>        <span class=\"token literal-property property\">foo</span><span class=\"token operator\">:</span><span class=\"token string\">'foo'</span>  </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span>  </pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token punctuation\">&#125;</span>  </pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token literal-property property\">inject</span><span class=\"token operator\">:</span><span class=\"token punctuation\">[</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">// 获取到祖先组件传递过来的值</span></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li>\n<p>Vuex</p>\n</li>\n</ol>\n<h2 id=\"vue中key的原理吗\"><a class=\"anchor\" href=\"#vue中key的原理吗\">#</a> vue 中 key 的原理吗</h2>\n<ol>\n<li>当我们在使用 <code>v-for</code>  时，需要给单元加上 <code>key</code></li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">v-for</span>=<span class=\"string\">&quot;item in items&quot;</span> <span class=\"attr\">:key</span>=<span class=\"string\">&quot;item.id&quot;</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>用 <code>+new Date()</code>  生成的时间戳作为 <code>key</code> ，手动强制触发重新渲染</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"title class_\">Comp</span> :key=<span class=\"string\">&quot;+new Date()&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在不使用 <code>key</code>  的情况，vue 会原地复用修改 DOM 值增加 DOM 操作</p>\n<p>设置 key 值不一定能提高 diff 效率。</p>\n",
            "tags": []
        }
    ]
}